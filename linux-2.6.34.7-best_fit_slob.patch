From 0a199f0b9e0a21f7d052658f23461782c40fc0b4 Mon Sep 17 00:00:00 2001
From: ClisbyS <clisbys@onid.orst.edu>
Date: Thu, 14 Oct 2010 17:32:47 -0700
Subject: [PATCH] Testing Git

---
 linux-2.6.34.7/Makefile |    2 ++
 1 files changed, 2 insertions(+), 0 deletions(-)

diff --git a/linux-2.6.34.7/Makefile b/linux-2.6.34.7/Makefile
index 290f058..a6b79e3 100644
--- a/linux-2.6.34.7/Makefile
+++ b/linux-2.6.34.7/Makefile
@@ -4,6 +4,8 @@ SUBLEVEL = 34
 EXTRAVERSION = .7
 NAME = Sheep on Meth
 
+# Git-testing!
+
 # *DOCUMENTATION*
 # To see a list of typical targets execute "make help"
 # More info can be located in ./README
-- 
1.5.2.1


From aeeb7e1fb2fd56ee1352207e4af32afe6c9fcfa5 Mon Sep 17 00:00:00 2001
From: CrawfordI <crawfoia@onid.orst.edu>
Date: Thu, 14 Oct 2010 17:37:56 -0700
Subject: [PATCH] Testing git as well.

---
 linux-2.6.34.7/Makefile |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/linux-2.6.34.7/Makefile b/linux-2.6.34.7/Makefile
index a6b79e3..d030ae6 100644
--- a/linux-2.6.34.7/Makefile
+++ b/linux-2.6.34.7/Makefile
@@ -4,7 +4,7 @@ SUBLEVEL = 34
 EXTRAVERSION = .7
 NAME = Sheep on Meth
 
-# Git-testing!
+# Git-testing! Indeed!
 
 # *DOCUMENTATION*
 # To see a list of typical targets execute "make help"
-- 
1.5.2.1


From 11995710c17aa3e3847abb7ca0efc98fb4eb2a6a Mon Sep 17 00:00:00 2001
From: Owner <matt@ubuntu.ubuntu-domain>
Date: Thu, 14 Oct 2010 17:42:24 -0700
Subject: [PATCH] Yellow Dragon

---
 linux-2.6.34.7/Makefile |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/linux-2.6.34.7/Makefile b/linux-2.6.34.7/Makefile
index d030ae6..8bb46ba 100644
--- a/linux-2.6.34.7/Makefile
+++ b/linux-2.6.34.7/Makefile
@@ -4,7 +4,7 @@ SUBLEVEL = 34
 EXTRAVERSION = .7
 NAME = Sheep on Meth
 
-# Git-testing! Indeed!
+# Git-testing! Indeed! BRILLIANT! 
 
 # *DOCUMENTATION*
 # To see a list of typical targets execute "make help"
-- 
1.5.2.1


From 479227ca4ab48113d70d5ae4ffa53a96fb53a0dd Mon Sep 17 00:00:00 2001
From: CrawfordI <crawfoia@onid.orst.edu>
Date: Sun, 24 Oct 2010 10:30:02 -0700
Subject: [PATCH] Adding Project 2 files(with functions already filled out)

---
 Proj2/Makefile         |   33 +++
 Proj2/cpu.c            |  612 ++++++++++++++++++++++++++++++++++++++++++++++++
 Proj2/cpu.o            |  Bin 0 -> 13208 bytes
 Proj2/cpuinit.c        |  336 ++++++++++++++++++++++++++
 Proj2/cpuinit.o        |  Bin 0 -> 6992 bytes
 Proj2/list.h           |  244 +++++++++++++++++++
 Proj2/macros.h         |   12 +
 Proj2/privatestructs.h |   34 +++
 Proj2/profile1         |   44 ++++
 Proj2/schedule.c       |  220 +++++++++++++++++
 Proj2/schedule.c~      |  181 ++++++++++++++
 Proj2/schedule.h       |   90 +++++++
 Proj2/schedule.o       |  Bin 0 -> 4712 bytes
 Proj2/schedule.old     |  217 +++++++++++++++++
 Proj2/vmsched          |  Bin 0 -> 20452 bytes
 15 files changed, 2023 insertions(+), 0 deletions(-)
 create mode 100644 Proj2/Makefile
 create mode 100644 Proj2/cpu.c
 create mode 100644 Proj2/cpu.o
 create mode 100644 Proj2/cpuinit.c
 create mode 100644 Proj2/cpuinit.o
 create mode 100644 Proj2/list.h
 create mode 100644 Proj2/macros.h
 create mode 100644 Proj2/privatestructs.h
 create mode 100644 Proj2/profile1
 create mode 100644 Proj2/schedule.c
 create mode 100644 Proj2/schedule.c~
 create mode 100644 Proj2/schedule.h
 create mode 100644 Proj2/schedule.o
 create mode 100644 Proj2/schedule.old
 create mode 100755 Proj2/vmsched

diff --git a/Proj2/Makefile b/Proj2/Makefile
new file mode 100644
index 0000000..a619f9c
--- /dev/null
+++ b/Proj2/Makefile
@@ -0,0 +1,33 @@
+PUBLICH = macros.h list.h
+PRIVATEH = privatestructs.h
+SCHEDULE = schedule.c schedule.h
+
+.PHONY: default
+default: clear app
+
+.PHONY: clear
+clear:
+	clear; clear
+	
+.PHONY: clean
+clean:
+	rm -f *.o
+	rm -f *.gch
+	rm -f vmsched
+	rm -f *.a
+
+.PHONY: lib
+lib: cpu.o cpuinit.o
+	ar rcs libvm.a cpu.o cpuinit.o
+
+app: cpu.o cpuinit.o  schedule.o
+	gcc -o vmsched cpuinit.o cpu.o schedule.o
+
+cpu.o: cpu.c $(SCHEDULE) $(PUBLICH) $(PRIVATEH)
+	gcc -c cpu.c
+
+cpuinit.o: cpuinit.c $(SCHEDULE) $(PUBLICH) $(PRIVATEH)
+	gcc -c cpuinit.c
+
+schedule.o: $(SCHEDULE) $(PUBLICH)
+	gcc -c schedule.c
diff --git a/Proj2/cpu.c b/Proj2/cpu.c
new file mode 100644
index 0000000..5b8c529
--- /dev/null
+++ b/Proj2/cpu.c
@@ -0,0 +1,612 @@
+/* cpu.c
+ * Main source for linux scheduler virtual machine.
+ * Emulates a simple CPU running processes with a generic interrupt
+ * for "IO."
+ *
+ * Requires a properly written schedule.c and schedule.h files 
+ * with stubs filled out.
+ */
+
+#include "privatestructs.h"
+#include "schedule.h"
+#include <unistd.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stddef.h>
+#include "list.h" 
+#include "macros.h"
+ 
+ /* Static methods */
+static void __init_sched();
+static int taskEnd();
+static void spawnChildren();
+static int cycle();
+static int interrupt();
+static void runcpu();
+static void killtask(struct task_struct **p);
+static void shutdowncpu();
+static void badshutdowncpu();
+static void cleanuptask(struct thread_info *p);
+static void forktask(struct thread_info *thread, struct task_struct *parent);
+
+/* External Prototypes */
+struct task_struct *createTask();
+struct thread_info *createInfo(const char *name);
+int readProfile(char *filename);
+
+/* Macros
+ * CLOCK_HZ - Sets the clock speed for the VM
+ * The other macros are bookkeeping
+ * macros for debugging output, and should
+ * be self-exlainitory.
+ */ 
+#define CLOCK_HZ 500000
+#define HZ_TO_MS (1000 / HZ)
+#define MS_TO_TICKS(ms) (CLOCK_HZ / 1000 * (ms)) 
+#define TICKS_TO_MS(tick) ((long long)((tick) / (long double)CLOCK_HZ * (1000)))
+
+#define LEVEL1(p, q) OUTPUT("", p, q)
+#define LEVEL2(p, q) OUTPUT("\t", p, q)
+#define LEVEL3(p, q) OUTPUT("\t\t", p, q)
+#define OUTPUT(o, p, q) (printf("%s%s/%d/%lldms - %s\n", (o), (p)->thread_info->processName, (p)->time_slice, TICKS_TO_MS(clocktick), (q)))
+#define ALERT(p) (printf("###-%s-###\n", (p)))
+ 
+/* Globals 
+ * jiffies - A jiffy represents the smallest unit of time that can occur
+ *			 between schedule ticks
+ * clocktick - The number of cycles the clock has run
+ * timer - A "hardware" timer that fires for schedule ticks
+ * processID - Next Process ID value
+ * rq - A poiner to the runqueue
+ * idle - Pointer to the idle task
+ * init - Pointer to the init task
+ * current - A pointer to the current process in the CPU
+ */
+long long jiffies = 0;
+long long clocktick = 0;
+long long timer = 0;
+unsigned int processID = 0;
+extern struct runqueue *rq;
+struct task_struct *idle = NULL;
+struct task_struct *init = NULL;
+extern struct task_struct *current;
+
+/* Control Data
+ * cycletime - The delay between cycles in the VM
+ * ranSeed - A random seed for the VM
+ * intTimer - The general "IO" interrupt, runs from a timer that is
+ *			  is randomly set when a process goes to sleep
+ * intWaitTimer - A process timer to dictate when an interactive process
+ *				  will go and wait on IO
+ * endtime - The time in ms when the VM will shutdown (approximately)
+ */
+long cycletime = 10;
+int ranSeed = 42;
+long long intTimer = -1;
+long long intWaitTimer = -1;
+long endtime = 1;
+ 
+/*-------------- INTERRUPT DATA ---------------*/
+/* This section has data specific to our
+ * machines "interrupts."
+ */
+/* Return Values */
+#define RESCHEDULE		1
+
+/* This is an IO wait queue */
+struct waitlist
+{
+	struct task_struct *task;
+	struct list_head list;
+};
+ 
+ /* Wait Queues
+  * This is the wait queue for our "IO"
+  */
+struct list_head intwaitlist;
+
+/*---------------APPLICATION LOGIC------------------*/
+
+/* main
+ * Takes a profile to load and run
+ */ 
+int main(int argc, char *argv[])
+{
+	if(argc < 2)
+	{
+		printf("Virtual Scheduler\nUsage: vsch [filename]\n");
+		return(1);
+	}
+
+	/* Initialize CPU and scheduler */
+	__init_sched();
+
+	/* Read in the profile */
+	if(!readProfile(argv[1]))
+		goto ERROR;
+		
+	/* Set the random seed we read in */
+	srand(ranSeed);
+	
+	/* Schedule the idle task to "prep" the scheduler */
+	ALERT("Starting CPU");
+	schedule();
+	/* Set first schedule tick timer */
+	timer = MS_TO_TICKS(HZ_TO_MS);
+	/* Start the CPU */
+	runcpu();
+	
+	/* Clean up from the CPU */
+	ALERT("Shutting Down CPU");
+	shutdowncpu();
+	
+	return(0);
+	
+ERROR:
+	/* Cleanup from an error */
+	badshutdowncpu();
+	shutdowncpu();
+	return(1);
+}
+
+/* ---------------------- VM FUNCTIONS -------------------*/
+/* runcpu
+ * This is the primary application loop that simulates
+ * our "CPU". This code also controls the checking
+ * of interrupts.
+ */
+static void runcpu()
+{
+	long long lastMS = 0;
+	
+	do
+	{
+		/* Run a single cycle of our application */
+		if(cycle())
+			goto END_CYCLE;
+	INTERRUPT:
+		/* Check for interrupts
+		 * This routine checks for fired
+		 * IO routines or timer ticks
+		 */
+		switch(interrupt())
+		{
+			/* Current task signaled for 
+			 * reschedule
+			 */
+			case RESCHEDULE:
+				clocktick++;
+				schedule();
+				goto END_CYCLE;
+			break;
+		}
+		
+		/* We've completed a clock cycle,
+		 * add a tick.
+		 */
+		clocktick++;
+	END_CYCLE:
+	
+		/* Check for ending conditions for our simulation */
+		if(!init->thread_info->kill && TICKS_TO_MS(clocktick) >= endtime)
+		{
+			ALERT("Sending Kill Message");
+			//isEnding = 1;
+			init->thread_info->kill = 1;
+		}
+		
+		/* Flush output and sleep */
+		fflush(stdout);
+		
+		if(TICKS_TO_MS(clocktick) > lastMS)
+		{
+			lastMS = TICKS_TO_MS(clocktick);
+			
+			if(cycletime > 0)
+				usleep(cycletime);
+		}
+
+	}while(rq->nr_running);
+}
+
+/* cycle
+ * Controls process logic, spawning and sleeping,
+ * as well as new process creation and process
+ * death.
+ */
+static int cycle()
+{
+	struct waitlist *tempwaitlist;
+	
+	/* Check to see if the task is ending */
+	if(taskEnd())
+		return(0);
+
+	/* Run logic based on task type */
+	switch(current->thread_info->thread_type)
+	{
+		case INIT:
+		break;
+		
+		/* Interactive tasks need to check to see
+		 * if they are going to wait on IO
+		 */
+		case INTERACTIVE:
+			/* Tick the timer for sleeping */
+			if(intWaitTimer > 0)
+				intWaitTimer--;
+				
+			/* When timer expires, sleep! */
+			if(intWaitTimer == 0)
+			{
+				intWaitTimer--;
+				LEVEL2(current, "Going to Sleep");
+				
+				/* Add task to wait queue */
+				tempwaitlist = (struct waitlist*)malloc(sizeof(struct waitlist));
+				INIT_LIST_HEAD(&tempwaitlist->list);
+				tempwaitlist->task = current;
+				list_add_tail(&tempwaitlist->list, &intwaitlist);
+				
+				/* Deactivate the task and remove it from the 
+				 * scheduler.
+				 */
+				deactivate_task(current);
+				
+				
+				/* We need to be rescheduled! */
+				current->need_reschedule = 1;
+			}
+		break;
+		
+		case NONINTERACTIVE:
+		break;
+	}
+	
+	/* If no other task has slept on IO, 
+	 * set a random time for the next "IO"
+	 * event.
+	 */
+	if(intTimer < 0)
+		intTimer = MS_TO_TICKS(rand() % 1000 + 50);
+	
+	/* Create any children */
+	spawnChildren();
+	
+	return(0);
+}
+
+/* interrupt
+ * Checks our computers interrupts
+ */
+static int interrupt()
+{	
+		struct list_head *listcur, *listnext;
+		struct waitlist *tempwaitlist;
+		
+	/*----------SCHEDULE TICK TIMER-------------*/
+		/* Decrement the timer */
+		if(timer > 0)
+			timer--;
+		
+		/* Timer Tick! Run the scheduler */
+		if(timer <= 0)
+		{
+			jiffies++;
+			timer = MS_TO_TICKS(HZ_TO_MS);
+			if(current->array != NULL)
+				scheduler_tick(current);
+		}
+
+	/*-------IO EVENT TIMER----------*/
+		/* Decrement the timer */
+		if(intTimer > 0)
+			intTimer--;
+		
+		/* Timer tick! */
+		if(intTimer == 0)
+		{
+			intTimer--;
+			listcur = intwaitlist.next;
+			
+			ALERT("An Interrupt has fired!");
+			
+			/* Check the IO waitlist to see if 
+			 * there are processes sleeping.
+			 */
+			while(listcur != &intwaitlist)
+			{
+				tempwaitlist = list_entry(listcur, struct waitlist, list);
+				LEVEL2(tempwaitlist->task, "Waking Up from Sleep");
+				activate_task(tempwaitlist->task);
+				listnext = listcur->next;
+				list_del(listcur);
+				free(tempwaitlist);
+				listcur = listnext;
+			}
+			
+			/* Notify that we need to reschedule! */
+			current->need_reschedule = 1;
+		}
+		
+		/* If a task needs rescheduling, alert! */
+		if(current->need_reschedule)
+			return(RESCHEDULE);
+		
+	return(0);
+}
+
+/*------------------ SYSTEM CALLS --------------------*/
+/* context_switch
+ * This performs a "context switch" for the
+ * scheduler.
+ */
+void context_switch(struct task_struct *next)
+{
+	LEVEL1(next, "Switching Process In");
+	
+	if(TICKS_TO_MS(clocktick) == 8790)
+		printf("BREAK\n");
+	
+	/* If this is an interactive task,
+	 * set random chance for sleep.
+	 */
+	if(next->thread_info->thread_type == INTERACTIVE)
+		intWaitTimer = MS_TO_TICKS(rand() % (next->time_slice * HZ / 1000 + 100) + 5);
+	
+	/* Set new task as current */
+	current = next;
+}
+
+/* sched_clock
+ * Returns the current time (approx)
+ * to the scheduler based on
+ * jiffies.
+ */
+unsigned long long sched_clock()
+{
+	return(JIFFIES_TO_NS(jiffies));
+}
+
+/*-------------------Local Methods-------------------*/
+
+/* __init_sched
+ * A pre-initialization function. Sets up
+ * Initial tasks and runqueue for scheduler
+ * before calling user's function to 
+ * setup custom queues.
+ */
+static void __init_sched()
+{
+	struct task_struct *task;
+
+	/* Create Init Task */
+	task = createTask();
+	task->thread_info = createInfo("Init");
+	task->thread_info->thread_type = INIT;
+	task->thread_info->kill_time = -1;
+
+	INIT_LIST_HEAD(&task->run_list);
+	INIT_LIST_HEAD(&task->thread_info->list);
+	//task->time_slice = task_timeslice(task);
+
+	/* Assign to global pointer for Config */
+	init = task;
+
+	/* Initialize Runqueue */
+	rq = (struct runqueue*)malloc(sizeof(struct runqueue));
+	rq->curr = NULL;
+	rq->nr_running = 0;
+	rq->nr_switches = 0;
+	rq->best_expired_prio = MAX_PRIO;
+	rq->expired_timestamp = 0;
+	
+	/* Initialize Scheduler */
+	initschedule(rq, init);
+	
+	/* Create Idle Task */
+	idle = createTask();
+	idle->thread_info = createInfo("IDLE");
+	processID--;
+	current = idle;
+	
+	/* Prepare List heads */
+	INIT_LIST_HEAD(&intwaitlist);
+}
+
+/* forktask
+ * Creates data structures for a new process being spawned
+ * from a parent. Finally, it submits the task to the
+ * scheduler.
+ */
+static void forktask(struct thread_info *thread, struct task_struct *parent)
+{
+	struct task_struct *task;
+	char str[1024];
+	
+	task = createTask();
+	task->thread_info = thread;
+	task->thread_info->id = processID++;
+	task->thread_info->children = 0;
+	task->thread_info->kill = 0;
+	
+	/* Assigne Thread Name */
+	if(parent->thread_info->parent != NULL)
+		sprintf(str, "%s:(%s:%d)", parent->thread_info->processName, task->thread_info->processName, task->thread_info->id);
+	else
+		sprintf(str, "(%s:%d)", task->thread_info->processName, task->thread_info->id);
+
+	free(task->thread_info->processName);
+	task->thread_info->processName = (char*)malloc(strlen(str) + 1);
+	memcpy(task->thread_info->processName, str, strlen(str) + 1);
+
+	/* If the parent is not INIT, display parent info */
+	if(thread->parent != NULL)
+		thread->parent->children++;
+	
+	/* Set NICE value */
+	task->static_prio = NICE_TO_PRIO(task->thread_info->niceValue);
+	
+	/* Alert Creation */
+	printf("###-Process: %s has been created-###\n", thread->processName);
+	/* Fork process in Scheduler */
+	sched_fork(task);
+	/* Wake up the task */
+	wake_up_new_task(task);
+	/* Signal need for schedule call */
+	current->need_reschedule = 1;
+}
+
+/* taskEnd
+ * Checks for an exit signal for the current 
+ * running task.
+ */
+static int taskEnd()
+{
+	/* Check to see if the time for this process to end
+	 * has passed.
+	 */
+	 if(current->thread_info->kill ||
+	    (current->thread_info->parent != NULL && current->thread_info->parent->kill) ||
+	    (current->thread_info->kill_time >= 0 && TICKS_TO_MS(clocktick) >= current->thread_info->kill_time)
+	   )
+	{
+		if(!current->thread_info->kill)
+			current->thread_info->kill = 1;
+		
+		if(current->thread_info->children == 0)
+		{
+			deactivate_task(current);
+			killtask(&current);
+			return(1);
+		}
+	}
+	
+	return(0);
+}
+
+/* spawnChildren
+ * Spanws children for processes
+ */
+static void spawnChildren()
+{
+	struct list_head *child, *next;;
+	struct thread_info *temp;
+
+	/* Make sure the current process can spawn */
+	if(current->thread_info->spawns)
+	{
+		/* Run through the list of children to be spawned */
+		child = &current->thread_info->list;
+		child = child->next;
+		while(child != &current->thread_info->list)
+		{
+			/* If it is time to spawn a child,
+			 * spawn that child.
+			 */
+			temp = list_entry(child, struct thread_info, clist);
+			if(MS_TO_TICKS(temp->spawn_time) <= clocktick) 
+			{
+				forktask(temp, current);
+				next = child;
+				child = child->next;
+				list_del(next);
+			}
+			else	
+				child = child->next;
+		}
+	}
+}
+
+/* killtask
+ * Kills the current running task and 
+ * removes it from the scheduler.
+ */
+static void killtask(struct task_struct **p)
+{
+	struct task_struct *j = *p;
+
+	printf("###-Process: %s is going down-###\n", j->thread_info->processName); 
+
+	/* If task has a parent, decrement the parent's
+	 * count of running children.
+	 */
+	if(j->thread_info->parent != NULL)
+		j->thread_info->parent->children--;
+	
+	/* Free data structures */
+	free(j->thread_info->processName);
+	free(j->thread_info);
+	free(j);
+	
+	/* Set the idle task in place
+	 * of the current one so the
+	 * scheduler works correctly.
+	 */
+	*p = idle;
+	j = *p;
+	
+	/* If there are still tasks to be run, run them. */
+	if(rq->nr_running != 0)
+		j->need_reschedule = 1;
+}
+
+/* shutdowncpu
+ * Releases data structures during a normal
+ * shutdown.
+ */
+static void shutdowncpu()
+{
+	free(idle->thread_info->processName);
+	free(idle->thread_info);
+	free(idle);
+	
+	/* Shuts down the scheduler */
+	killschedule();
+	/* Free the runqueue */
+	free(rq);
+}
+
+/* badshutdowncpu
+ * Frees data structures left in memory when
+ * an error occurs.
+ */
+static void badshutdowncpu()
+{
+	cleanuptask(init->thread_info);
+	
+	if(init->thread_info->processName != NULL)
+		free(init->thread_info->processName);
+	free(init->thread_info);
+	free(init);
+}
+
+/* cleanuptask
+ * A recursive helper function
+ * for badshutdowncpu which
+ * recursively frees child tasks
+ */
+static void cleanuptask(struct thread_info *p)
+{
+	struct list_head *child, *next;
+	struct thread_info *temp;
+
+	child = &p->list;
+	child = child->next;
+	while(child != NULL && child != &p->list)
+	{
+		temp = list_entry(child, struct thread_info, clist);
+		next = child;
+		child = child->next;
+		list_del(next);
+		
+		/* Clean up task children */
+		cleanuptask(temp);
+		
+		/* Clean up this task */
+		if(temp->processName != NULL)
+			free(temp->processName);
+		free(temp);
+	}
+}
\ No newline at end of file
diff --git a/Proj2/cpu.o b/Proj2/cpu.o
new file mode 100644
index 0000000000000000000000000000000000000000..4e3c4e50a53cf52fdf17c1a2d232d1dcda5ffdfa
GIT binary patch
literal 13208
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

literal 0
Hc$@<O00001

diff --git a/Proj2/cpuinit.c b/Proj2/cpuinit.c
new file mode 100644
index 0000000..719a2be
--- /dev/null
+++ b/Proj2/cpuinit.c
@@ -0,0 +1,336 @@
+/* cpuinit.c
+ * Contains a few *large* helper functions
+ * for initializing the virtual machine.
+ * The main guts here is the parser,
+ * which is fairly large and parses
+ * the CPU profiles.
+ */
+ 
+#include <stdio.h>
+#include <stdlib.h>
+#include "schedule.h"
+#include "privatestructs.h"
+#include <string.h>
+
+/* Parse Data */
+#define CSIZE 12
+#define TSIZE 2
+
+/* The various parse options */
+char *coptions[CSIZE] = 	{
+"CYCLE_TIME",
+"NEWPROCESS",
+"ENDPROCESS",
+"SPAWNTIME", 
+"NAME",
+"TYPE",
+"SEED", 
+"ENDTIME",
+"KILLTIME",
+"NICE",
+"SPAWN",
+"ENDSPAWN"
+};
+
+/* Type Options */
+char *ttype[TSIZE] = {
+"INTERACTIVE",
+"NONINTERACTIVE"
+};
+
+int tint[TSIZE] = {
+INTERACTIVE,
+NONINTERACTIVE
+};
+
+/* Static prototypes */
+static int readint(FILE *fp);
+static void readstring(FILE *fp, char **str);
+
+/* External References */
+extern struct task_struct *idle;
+extern struct task_struct *init;
+extern int processID;
+extern int cycletime;
+extern int ranSeed;
+extern long endtime;
+
+/* createTask 
+ * Helper method that creates and zeros
+ * a task_struct.
+ */
+struct task_struct *createTask()
+{
+	struct task_struct *task;
+	
+	task = (struct task_struct*)malloc(sizeof(struct task_struct));
+	task->thread_info = (struct thread_info*)malloc(sizeof(struct thread_info));
+	task->static_prio = NICE_TO_PRIO(0);
+	task->prio = 0;
+	task->sleep_avg = 0;
+	task->time_slice = 0;
+	task->first_time_slice = 0;
+	task->need_reschedule = 0;
+	task->last_ran = 0;
+	task->timestamp = 0;
+	
+	return(task);
+}
+
+/* createInfo
+ * Helper method that creates and zeros
+ * a thread_info struct.
+ */
+struct thread_info *createInfo(const char *name)
+{
+	struct thread_info *thread_info;
+	char pname[1024];
+	
+	thread_info = (struct thread_info*)malloc(sizeof(struct thread_info));
+	thread_info->id = processID++;
+	thread_info->parent = NULL;
+	thread_info->spawns = 0;
+	thread_info->niceValue = 0;
+	thread_info->kill = 0;
+	thread_info->thread_type = -1;
+	thread_info->children = 0;
+	thread_info->type_struct = NULL;
+	sprintf(pname, "%d", thread_info->id);
+	thread_info->processName = (char *)malloc(strlen(name) + strlen(pname) + 4);
+	sprintf(thread_info->processName, "(%s:%s)", name, pname);
+	
+	return(thread_info);
+}
+
+/* readProfile
+ * Main body of parser.
+ */
+int readProfile(char *filename)
+{
+	int i, j, offset;
+	char copt[50];
+	char *temp;
+	FILE *fp;
+	int children = 0;
+	struct thread_info *newtask = NULL;
+	struct thread_info *old;
+	struct thread_info *top = init->thread_info;
+	top->spawns = 1;
+	
+	if((fp = fopen(filename, "r")) == NULL)
+	{
+		printf("ERROR: profile %s not found\n", filename);
+		return(0);
+	}
+
+	while(!feof(fp))
+	{
+		/* Eat Whitespace */
+		WHITESPACE:
+			if(!fread(copt, 1, 1, fp))
+				continue;
+			if(isspace(*copt))
+				goto WHITESPACE;
+
+		/* Ignore whitespace */
+		if(*copt == ';')
+		{
+			while(*copt != '\n')
+				if(!fread(copt, 1, 1, fp))
+					continue;
+			if(*copt != '#')
+				continue;
+		}
+
+		if(*copt != '#')
+		{
+			printf("Missing '#' at beginning of command\n");
+			return(0);
+		}
+
+		/* Read option */
+		i = 0;
+		while(!feof(fp))
+		{
+			if(i >= 48)
+				return(0);
+
+			if(!fread((copt + i), 1, 1, fp))
+				goto WHITESPACE;
+			if(isspace(*(copt + i)))
+				break;
+			i++;
+		};
+
+		*(copt + i) = '\0';
+
+		/* Parse Option */
+		offset = -1;
+		for(i = 0; i < CSIZE; i++)
+		{
+			/*printf("Comparing %s to %s\n", copt, coptions[i]);*/
+
+			if(strcmp(copt, coptions[i]) == 0)
+			{
+				offset = i;
+				break;
+			}
+			
+		}
+
+		if(offset == -1)
+		{
+			printf("Command %s is unknown\n", copt);
+			return(0);
+		}
+
+		/* Eat Whitespace */
+		WHITESPACE_VAL:
+			if(!fread(copt, 1, 1, fp))
+				continue;
+			if(isspace(*copt))
+				goto WHITESPACE_VAL;
+
+		fseek(fp, -1, SEEK_CUR);
+
+		/* Parse Value
+		 * Switched off of parse array
+		 */
+		switch(i)
+		{
+			/* Read Int */
+			case 0: /* Cycle Delay */
+				cycletime = readint(fp);
+			break;
+			
+			case 1: /* New Process */
+				newtask = (struct thread_info*)malloc(sizeof(struct thread_info));
+				newtask->kill_time = -1;
+				newtask->niceValue = 0;
+				newtask->parent = top;
+				INIT_LIST_HEAD(&newtask->list);
+				list_add_tail(&newtask->clist, &top->list);
+			break;
+			
+			case 2: /* End Process */
+				newtask = NULL;
+			break;
+			
+			case 3: /* Spawn Time */
+				newtask->spawn_time = readint(fp);
+			break;
+				
+			case 4: /* Name */
+				readstring(fp, &newtask->processName);
+			break;
+			
+			case 5: /* Type */
+				readstring(fp, &temp);
+				offset = 0;
+				for(j = 0; j < TSIZE; j++)
+				{
+					if(strcmp(ttype[j], temp) == 0)
+					{
+						newtask->thread_type = tint[j];
+						offset = 1;
+					}
+				}
+				
+				if(!offset)
+					printf("Bad type!\n");
+			break;
+			
+			case 6: /* randomd seed */
+				ranSeed = readint(fp);
+			break;
+			
+			case 7: /* endtime */
+				endtime = readint(fp);
+			break;
+			
+			case 8: /* Kill time */
+				newtask->kill_time = readint(fp);
+			break;
+			
+			case 9: /* Nice Value */
+				newtask->niceValue = readint(fp);
+				if(newtask->niceValue < -19 || newtask->niceValue > 20)
+					newtask->niceValue = 0;
+			break;
+			
+			case 10: /* SPAWN */
+				children++;
+				top = newtask;
+				top->spawns = 1;
+			break;
+			
+			case 11: /* ENDSPAWN */
+				children--;
+				old = top;
+				top = top->parent;
+				newtask = old;
+			break;
+			
+			default:
+				return(0);
+			break;
+		}
+	}
+	
+
+	fclose(fp);
+
+	if(children)
+		return(0);
+		
+	return(1);
+}
+
+/* readint
+ * Helper function. Reads an integer from
+ * the file.
+ */
+static int readint(FILE *fp)
+{
+	int val;
+
+	fscanf(fp, "%d", &val);
+	
+	return(val);
+}
+
+/* readstring
+ * Helper function. Reads a 
+ * string from the file.
+ */
+static void readstring(FILE *fp, char **str)
+{
+	int i = 0, j = 0;
+	char c;	
+
+	*str = NULL;
+
+	while(!feof(fp))
+	{
+		if(!fread(&c, 1, 1, fp))
+			continue;
+		if(isspace(c))
+			break;
+
+		i++;
+	}
+	
+	if(i == 0)
+		return;
+
+	*str = (char*)malloc(sizeof(char) * (i + 1));
+
+	fseek(fp, -i - 1, SEEK_CUR);
+	
+	for(j = 0; j < i; j++)
+		fread((*str + j), 1, 1, fp);
+	
+	*(*str + i) = '\0';
+
+	return;
+}
diff --git a/Proj2/cpuinit.o b/Proj2/cpuinit.o
new file mode 100644
index 0000000000000000000000000000000000000000..28110030bc7f86af84ee0a788db615e9dcc0fd1e
GIT binary patch
literal 6992
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
PH#u&8S1)kf{C@s7(6@5-

literal 0
Hc$@<O00001

diff --git a/Proj2/list.h b/Proj2/list.h
new file mode 100644
index 0000000..3a76885
--- /dev/null
+++ b/Proj2/list.h
@@ -0,0 +1,244 @@
+#ifndef __LIST_H
+#define __LIST_H
+
+/* This file is from Linux Kernel (include/linux/list.h) 
+ * and modified by simply removing hardware prefetching of list items. 
+ * Here by copyright, credits attributed to wherever they belong.
+ * Kulesh Shanmugasundaram (kulesh [squiggly] isis.poly.edu)
+ */
+
+/*
+ * Simple doubly linked list implementation.
+ *
+ * Some of the internal functions ("__xxx") are useful when
+ * manipulating whole lists rather than single entries, as
+ * sometimes we already know the next/prev entries and we can
+ * generate better code by using them directly rather than
+ * using the generic single-entry routines.
+ */
+
+struct list_head {
+	struct list_head *next, *prev;
+};
+
+#define LIST_HEAD_INIT(name) { &(name), &(name) }
+
+#define LIST_HEAD(name) \
+	struct list_head name = LIST_HEAD_INIT(name)
+
+#define INIT_LIST_HEAD(ptr) do { \
+	(ptr)->next = (ptr); (ptr)->prev = (ptr); \
+} while (0)
+
+/*
+ * Insert a new entry between two known consecutive entries. 
+ *
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ */
+static inline void __list_add(struct list_head *new,
+			      struct list_head *prev,
+			      struct list_head *next)
+{
+	next->prev = new;
+	new->next = next;
+	new->prev = prev;
+	prev->next = new;
+}
+
+/**
+ * list_add - add a new entry
+ * @new: new entry to be added
+ * @head: list head to add it after
+ *
+ * Insert a new entry after the specified head.
+ * This is good for implementing stacks.
+ */
+static inline void list_add(struct list_head *new, struct list_head *head)
+{
+	__list_add(new, head, head->next);
+}
+
+/**
+ * list_add_tail - add a new entry
+ * @new: new entry to be added
+ * @head: list head to add it before
+ *
+ * Insert a new entry before the specified head.
+ * This is useful for implementing queues.
+ */
+static inline void list_add_tail(struct list_head *new, struct list_head *head)
+{
+	__list_add(new, head->prev, head);
+}
+
+/*
+ * Delete a list entry by making the prev/next entries
+ * point to each other.
+ *
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ */
+static inline void __list_del(struct list_head *prev, struct list_head *next)
+{
+	next->prev = prev;
+	prev->next = next;
+}
+
+/**
+ * list_del - deletes entry from list.
+ * @entry: the element to delete from the list.
+ * Note: list_empty on entry does not return true after this, the entry is in an undefined state.
+ */
+static inline void list_del(struct list_head *entry)
+{
+	__list_del(entry->prev, entry->next);
+	entry->next = (void *) 0;
+	entry->prev = (void *) 0;
+}
+
+/**
+ * list_del_init - deletes entry from list and reinitialize it.
+ * @entry: the element to delete from the list.
+ */
+static inline void list_del_init(struct list_head *entry)
+{
+	__list_del(entry->prev, entry->next);
+	INIT_LIST_HEAD(entry); 
+}
+
+/**
+ * list_move - delete from one list and add as another's head
+ * @list: the entry to move
+ * @head: the head that will precede our entry
+ */
+static inline void list_move(struct list_head *list, struct list_head *head)
+{
+        __list_del(list->prev, list->next);
+        list_add(list, head);
+}
+
+/**
+ * list_move_tail - delete from one list and add as another's tail
+ * @list: the entry to move
+ * @head: the head that will follow our entry
+ */
+static inline void list_move_tail(struct list_head *list,
+				  struct list_head *head)
+{
+        __list_del(list->prev, list->next);
+        list_add_tail(list, head);
+}
+
+/**
+ * list_empty - tests whether a list is empty
+ * @head: the list to test.
+ */
+static inline int list_empty(struct list_head *head)
+{
+	return head->next == head;
+}
+
+static inline void __list_splice(struct list_head *list,
+				 struct list_head *head)
+{
+	struct list_head *first = list->next;
+	struct list_head *last = list->prev;
+	struct list_head *at = head->next;
+
+	first->prev = head;
+	head->next = first;
+
+	last->next = at;
+	at->prev = last;
+}
+
+/**
+ * list_splice - join two lists
+ * @list: the new list to add.
+ * @head: the place to add it in the first list.
+ */
+static inline void list_splice(struct list_head *list, struct list_head *head)
+{
+	if (!list_empty(list))
+		__list_splice(list, head);
+}
+
+/**
+ * list_splice_init - join two lists and reinitialise the emptied list.
+ * @list: the new list to add.
+ * @head: the place to add it in the first list.
+ *
+ * The list at @list is reinitialised
+ */
+static inline void list_splice_init(struct list_head *list,
+				    struct list_head *head)
+{
+	if (!list_empty(list)) {
+		__list_splice(list, head);
+		INIT_LIST_HEAD(list);
+	}
+}
+
+/**
+ * list_entry - get the struct for this entry
+ * @ptr:	the &struct list_head pointer.
+ * @type:	the type of the struct this is embedded in.
+ * @member:	the name of the list_struct within the struct.
+ */
+#define list_entry(ptr, type, member) \
+	((type *)((char *)(ptr)-(unsigned long)(&((type *)0)->member)))
+
+/**
+ * list_for_each	-	iterate over a list
+ * @pos:	the &struct list_head to use as a loop counter.
+ * @head:	the head for your list.
+ */
+#define list_for_each(pos, head) \
+	for (pos = (head)->next; pos != (head); \
+        	pos = pos->next)
+/**
+ * list_for_each_prev	-	iterate over a list backwards
+ * @pos:	the &struct list_head to use as a loop counter.
+ * @head:	the head for your list.
+ */
+#define list_for_each_prev(pos, head) \
+	for (pos = (head)->prev; pos != (head); \
+        	pos = pos->prev)
+        	
+/**
+ * list_for_each_safe	-	iterate over a list safe against removal of list entry
+ * @pos:	the &struct list_head to use as a loop counter.
+ * @n:		another &struct list_head to use as temporary storage
+ * @head:	the head for your list.
+ */
+#define list_for_each_safe(pos, n, head) \
+	for (pos = (head)->next, n = pos->next; pos != (head); \
+		pos = n, n = pos->next)
+
+/**
+ * list_for_each_entry	-	iterate over list of given type
+ * @pos:	the type * to use as a loop counter.
+ * @head:	the head for your list.
+ * @member:	the name of the list_struct within the struct.
+ */
+#define list_for_each_entry(pos, head, member)				\
+	for (pos = list_entry((head)->next, typeof(*pos), member);	\
+	     &pos->member != (head); 					\
+	     pos = list_entry(pos->member.next, typeof(*pos), member))
+
+/**
+ * list_for_each_entry_safe - iterate over list of given type safe against removal of list entry
+ * @pos:	the type * to use as a loop counter.
+ * @n:		another type * to use as temporary storage
+ * @head:	the head for your list.
+ * @member:	the name of the list_struct within the struct.
+ */
+#define list_for_each_entry_safe(pos, n, head, member)			\
+	for (pos = list_entry((head)->next, typeof(*pos), member),	\
+		n = list_entry(pos->member.next, typeof(*pos), member);	\
+	     &pos->member != (head); 					\
+	     pos = n, n = list_entry(n->member.next, typeof(*n), member))
+
+
+#endif
diff --git a/Proj2/macros.h b/Proj2/macros.h
new file mode 100644
index 0000000..cd48fd9
--- /dev/null
+++ b/Proj2/macros.h
@@ -0,0 +1,12 @@
+#ifndef MACROS_H
+#define MACROS_H
+
+#define HZ 100
+
+#define MAX_PRIO 1
+#define NICE_TO_PRIO(p) (0)
+
+#define JIFFIES_TO_NS(TIME) ((TIME) * (1000000000 / HZ))
+#define NS_TO_JIFFIES(TIME) ((TIME) / (1000000000 / HZ))
+
+#endif
\ No newline at end of file
diff --git a/Proj2/privatestructs.h b/Proj2/privatestructs.h
new file mode 100644
index 0000000..197750a
--- /dev/null
+++ b/Proj2/privatestructs.h
@@ -0,0 +1,34 @@
+/* privatestruct
+ * This file contains data structures that are 
+ * exclusively for the VM, and should not be
+ * accessible to the scheduler.
+ */
+
+#ifndef PRIVATESTRUCTS_H
+#define PRIVATESTRUCTS_H
+
+#include "list.h"
+
+// Task Types
+#define INIT				0
+#define INTERACTIVE			1
+#define NONINTERACTIVE		2
+
+struct thread_info
+{
+	int id;
+	int spawn_time;
+	int kill_time;
+	int niceValue;
+	int spawns;
+	int children;
+	int kill;
+	int thread_type;
+	void *type_struct;
+	char *processName;
+	struct thread_info *parent;
+	struct list_head list;
+	struct list_head clist;
+};
+
+#endif
\ No newline at end of file
diff --git a/Proj2/profile1 b/Proj2/profile1
new file mode 100644
index 0000000..d1a328a
--- /dev/null
+++ b/Proj2/profile1
@@ -0,0 +1,44 @@
+#CYCLE_TIME 0
+#SEED 345
+#ENDTIME 10000
+
+#NEWPROCESS
+#TYPE INTERACTIVE
+#NAME Sleeper
+#NICE -10
+#SPAWNTIME 562
+#ENDPROCESS
+
+#NEWPROCESS 
+#TYPE INTERACTIVE
+#NAME Interactive
+#SPAWNTIME 100
+#KILLTIME 400
+#ENDPROCESS
+
+#NEWPROCESS 
+#TYPE INTERACTIVE
+#NAME Interactive
+#SPAWNTIME 500
+#ENDPROCESS
+
+#NEWPROCESS
+#TYPE INTERACTIVE
+#NAME Non-Interactive
+#SPAWNTIME 324
+#NICE 4
+#ENDPROCESS
+
+#NEWPROCESS
+#TYPE NONINTERACTIVE
+#NAME Spawner
+#SPAWNTIME 1
+#NICE 20
+#SPAWN
+	#NEWPROCESS
+	#TYPE INTERACTIVE
+	#NAME Interactive
+	#SPAWNTIME 200
+	#ENDPROCESS
+#ENDSPAWN
+#ENDPROCESS
diff --git a/Proj2/schedule.c b/Proj2/schedule.c
new file mode 100644
index 0000000..9532349
--- /dev/null
+++ b/Proj2/schedule.c
@@ -0,0 +1,220 @@
+/* schedule.c
+ * This file contains the primary logic for the 
+ * scheduler.
+ */
+#include "schedule.h"
+#include "macros.h"
+#include <stddef.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define NEWTASKSLICE (NS_TO_JIFFIES(100000000))
+
+/* Local Globals
+ * rq - This is a pointer to the runqueue that the scheduler uses.
+ * current - A pointer to the current running task.
+ */
+struct runqueue *rq;
+struct task_struct *current;
+
+/* External Globals
+ * jiffies - A discrete unit of time used for scheduling.
+ *			 There are HZ jiffies in a second, (HZ is 
+ *			 declared in macros.h), and is usually
+ *			 1 or 10 milliseconds.
+ */
+extern long long jiffies;
+
+
+/*-----------------Initilization/Shutdown Code-------------------*/
+/* This code is not used by the scheduler, but by the virtual machine
+ * to setup and destroy the scheduler cleanly.
+ */
+ 
+ /* initscheduler
+  * Sets up and allocates memory for the scheduler, as well
+  * as sets initial values. This function should also
+  * set the initial effective priority for the "seed" task 
+  * and enqueu it in the scheduler.
+  * INPUT:
+  * newrq - A pointer to an allocated rq to assign to your
+  *			local rq.
+  * seedTask - A pointer to a task to seed the scheduler and start
+  * the simulation.
+  */
+
+void initschedule(struct runqueue *newrq, struct task_struct *seedTask)
+{
+    printf( "Begin init.\n" );
+    struct sched_array* actual;
+
+    newrq->nr_running = 1;
+    newrq->nr_switches = 0;
+
+    actual = malloc( 2 *  sizeof( struct sched_array ) );
+    newrq->arrays[ 0 ] = actual[ 0 ];
+
+    newrq->active = &newrq->arrays[ 0 ];
+    INIT_LIST_HEAD( &newrq->arrays[ 0 ].array );
+
+    enqueue_task( seedTask, newrq->active );
+
+    seedTask->need_reschedule = 1;
+
+    seedTask->first_time_slice = NEWTASKSLICE;
+    seedTask->time_slice = NEWTASKSLICE;
+
+    rq = newrq;
+}
+
+/* killschedule
+ * This function should free any memory that 
+ * was allocated when setting up the runqueu.
+ * It SHOULD NOT free the runqueue itself.
+ */
+void killschedule()
+{
+    printf( "Begin Kill.\n" );
+
+    //free( rq->arrays );
+
+}
+
+/*-------------Scheduler Code Goes Below------------*/
+/* This is the beginning of the actual scheduling logic */
+
+/* schedule
+ * Gets the next task with the shortest runtime(time slice) remaining
+ */
+void schedule()
+{
+    //printf( "Calling schedule\n" );
+
+    struct list_head* pos = NULL;
+
+    struct task_struct *task = NULL;
+    struct task_struct *next = NULL;
+    
+    unsigned int rem_time = -1;
+  
+    list_for_each( pos, &rq->active->array )
+        {
+        task = list_entry( pos, struct task_struct, run_list );
+        if( task->need_reschedule )
+	    {
+   	   	if( task->time_slice <= 0 )
+		{
+		    task->time_slice = task->first_time_slice;
+                    task->need_reschedule = 1;
+		}
+		else if( task->time_slice < rem_time )
+		{
+ 		    next = task;
+                    rem_time = task->time_slice;
+		}
+	    }
+        }
+    if( next != NULL && next != current )
+	{	
+	    rq->nr_switches++;
+            context_switch( next );
+            rq->curr = next;
+            next->need_reschedule = 0;
+	}
+}
+
+
+/* enqueue_task
+ * Enqeueus a task in the passed sched_array
+ */
+void enqueue_task(struct task_struct *p, struct sched_array *array)
+{
+    //printf( "Calling enqueue_task\n" );
+    list_add( &p->run_list, &array->array );
+    p->array = array;
+    rq->nr_running++;
+}
+
+/* dequeue_task
+ * Removes a task from the passed sched_array
+ */
+void dequeue_task(struct task_struct *p, struct sched_array *array)
+{
+    //printf( "Calling dequue_task\n" );
+
+    list_del( &p->run_list );
+    p->array = NULL;   
+    rq->nr_running--;
+}
+
+/* sched_fork
+ * Sets up schedule info for a newly forked task
+ */
+void sched_fork(struct task_struct *p)
+{	
+    //printf( "Calling sched_fork\n" );
+    printf( "%d\n", sched_clock() );
+    p->first_time_slice = current->first_time_slice / 2;
+    p->time_slice = p->first_time_slice;
+}
+
+/* scheduler_tick
+ * Updates information and priority
+ * for the task that is currently running.
+ */
+void scheduler_tick(struct task_struct *p)
+{	
+    p->time_slice--;
+    if( p->time_slice == 0 )
+    {
+        p->need_reschedule = 1;
+    }
+}
+
+/* wake_up_new_task
+ * Prepares information for a task
+ * that is waking up for the first time
+ * (being created).
+ * Also handles preemption, e.g. decides 
+ * whether or not the current task should
+ * call scheduler to allow for this one to run
+ */
+void wake_up_new_task(struct task_struct *p)
+{	
+
+    enqueue_task( p, rq->active );
+    p->need_reschedule = 1;
+}
+
+/* __activate_task
+ * Activates the task in the scheduler
+ * by adding it to the active array.
+ */
+void __activate_task(struct task_struct *p)
+{
+    enqueue_task( p, rq->active );
+}
+
+/* activate_task
+ * Activates a task that is being woken-up
+ * from sleeping.
+ */
+void activate_task(struct task_struct *p)
+{	
+    //printf( "Calling activate_task\n" );
+    __activate_task( p );
+    p->need_reschedule = 1;
+}
+
+/* deactivate_task
+ * Removes a running task from the scheduler to
+ * put it to sleep.
+ */
+void deactivate_task(struct task_struct *p)
+{
+    //printf( "Calling deactivate_task\n" );
+    p->need_reschedule = 0;
+    dequeue_task( p , rq->active);
+    printf( "deactive done\n" );
+}
diff --git a/Proj2/schedule.c~ b/Proj2/schedule.c~
new file mode 100644
index 0000000..058444e
--- /dev/null
+++ b/Proj2/schedule.c~
@@ -0,0 +1,181 @@
+/* schedule.c
+ * This file contains the primary logic for the 
+ * scheduler.
+ */
+#include "schedule.h"
+#include "macros.h"
+#include <stddef.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define NEWTASKSLICE (NS_TO_JIFFIES(100000000))
+#define NUMPRIOR 140;
+
+/* Local Globals
+ * rq - This is a pointer to the runqueue that the scheduler uses.
+ * current - A pointer to the current running task.
+ */
+struct runqueue *rq;
+struct task_struct *current;
+
+/* External Globals
+ * jiffies - A discrete unit of time used for scheduling.
+ *			 There are HZ jiffies in a second, (HZ is 
+ *			 declared in macros.h), and is usually
+ *			 1 or 10 milliseconds.
+ */
+extern long long jiffies;
+
+
+/*-----------------Initilization/Shutdown Code-------------------*/
+/* This code is not used by the scheduler, but by the virtual machine
+ * to setup and destroy the scheduler cleanly.
+ */
+ 
+ /* initscheduler
+  * Sets up and allocates memory for the scheduler, as well
+  * as sets initial values. This function should also
+  * set the initial effective priority for the "seed" task 
+  * and enqueu it in the scheduler.
+  * INPUT:
+  * newrq - A pointer to an allocated rq to assign to your
+  *			local rq.
+  * seedTask - A pointer to a task to seed the scheduler and start
+  * the simulation.
+  */
+void initschedule(struct runqueue *newrq, struct task_struct *seedTask)
+{
+    printf( "Begin init.\n" );
+    //struct sched_array actual[ 2 ];
+    struct sched_array* actual;
+
+    newrq->nr_running = 1;
+    newrq->nr_switches = 0;
+    newrq->expired_timestamp = 0;
+    newrq->most_recent_timestamp = 0;
+    newrq->curr = seedTask;
+
+    actual = malloc( 2 * sizeof( struct sched_array ) );
+    newrq->arrays[ 0 ] = actual[ 0 ];
+    newrq->arrays[ 1 ] = actual[ 1 ];
+
+    newrq->active = &newrq->arrays[ 0 ];
+    //newrq->expired = &newrq->arrays[ 1 ];
+
+    //INIT_LIST_HEAD( newrq->arrays[ 0 ].array )
+
+    newrq->active->array.next = &seedTask->run_list;
+    newrq->active->array.prev = &seedTask->run_list;
+
+    //seedTask->need_reschedule = 1; 
+
+    newrq->best_expired_prio = 0;
+
+    seedTask->prio = NUMPRIOR;
+    seedTask->static_prio = NUMPRIOR;
+    seedTask->normal_prio = NUMPRIOR;
+
+    rq = newrq;
+
+    printf( "Finish init.\n" );
+}
+
+/* killschedule
+ * This function should free any memory that 
+ * was allocated when setting up the runqueu.
+ * It SHOULD NOT free the runqueue itself.
+ */
+void killschedule()
+{
+    printf( "Begin Kill.\n" );
+    free( rq->arrays );
+    printf( "Finished kill.\n" );
+}
+
+/*-------------Scheduler Code Goes Below------------*/
+/* This is the beginning of the actual scheduling logic */
+
+/* schedule
+ * Gets the next task with the shortest runtime(time slice) remaining
+ */
+void schedule()
+{
+    printf( "Calling schedule\n" );
+    sleep( 1 );
+}
+
+
+/* enqueue_task
+ * Enqeueus a task in the passed sched_array
+ */
+void enqueue_task(struct task_struct *p, struct sched_array *array)
+{
+    printf( "Calling enqueue_task\n" );
+    list_add( &p->run_list, &array->array );
+}
+
+/* dequeue_task
+ * Removes a task from the passed sched_array
+ */
+void dequeue_task(struct task_struct *p, struct sched_array *array)
+{
+    printf( "Calling dequue_task\n" );
+    list_del( &p->run_list, &array->array );
+}
+
+/* sched_fork
+ * Sets up schedule info for a newly forked task
+ */
+void sched_fork(struct task_struct *p)
+{	
+    printf( "Calling sched_fork\n" );
+}
+
+/* scheduler_tick
+ * Updates information and priority
+ * for the task that is currently running.
+ */
+void scheduler_tick(struct task_struct *p)
+{	
+    printf( "Calling scheduler_tick\n" );
+}
+
+/* wake_up_new_task
+ * Prepares information for a task
+ * that is waking up for the first time
+ * (being created).
+ * Also handles preemption, e.g. decides 
+ * whether or not the current task should
+ * call scheduler to allow for this one to run
+ */
+void wake_up_new_task(struct task_struct *p)
+{	
+    printf( "Calling wake_up_new_task\n" );
+}
+
+/* __activate_task
+ * Activates the task in the scheduler
+ * by adding it to the active array.
+ */
+void __activate_task(struct task_struct *p)
+{
+}
+
+/* activate_task
+ * Activates a task that is being woken-up
+ * from sleeping.
+ */
+void activate_task(struct task_struct *p)
+{		
+    printf( "Calling activate_task\n" );
+}
+
+/* deactivate_task
+ * Removes a running task from the scheduler to
+ * put it to sleep.
+ */
+void deactivate_task(struct task_struct *p)
+{
+    printf( "Calling deactivate_task\n" );
+}
diff --git a/Proj2/schedule.h b/Proj2/schedule.h
new file mode 100644
index 0000000..425e4b0
--- /dev/null
+++ b/Proj2/schedule.h
@@ -0,0 +1,90 @@
+#ifndef SCHEDULE_H
+#define SCHEDULE_H
+
+#include "macros.h"
+#include "list.h"
+
+struct thread_info;
+
+/* ------------- This is modified by the programmer ------------ */
+/* sched_array is the primary data structure used by the scheduler.
+ * We have left it to be modified by you so that you may 
+ * implement any type of scheduler that you want.
+ */
+struct sched_array {
+	struct list_head array;
+};
+
+/* ---------------- Do NOT Touch -------------- */
+/* Sleep Types */
+enum sleep_type
+{
+	SLEEP_NORMAL,
+	SLEEP_NONINTERACTIVE,
+	SLEEP_INTERACTIVE,
+	SLEEP_INTERRUPTED
+};
+
+/* task_struct */
+struct task_struct
+{
+	struct thread_info *thread_info;			/* Information about the thread */
+	int prio, static_prio, normal_prio;			/* Priority values */	
+	unsigned long sleep_avg;					/* The average time the task
+												   has been sleeping */
+	unsigned long long last_ran;				/* Timestamp for when the
+												   task was last run. */
+	unsigned long long timestamp;				/* A timestamp value */
+	unsigned long long sched_time;				/* The amount of time task
+												   was waiting to be scheduled */
+	unsigned int time_slice, first_time_slice;	/* Timeslice values */
+	struct list_head run_list;					/* Linked list for sched_array */
+	struct sched_array *array;					/* The sched_array the task is in */
+	enum sleep_type sleep_type;					/* What type of sleep task is in */
+	int need_reschedule;						/* Flag, set if task needs to
+												   have schedule called */
+};
+
+/* runqueue */
+struct runqueue {
+    unsigned long    nr_running;				/* number of runnable tasks */
+    unsigned long    nr_switches;				/* number of contextswitches */
+    unsigned long    expired_timestamp;			/* time of last array swap */
+	unsigned long long most_recent_timestamp;	/* The last time schedule was run */
+    struct task_struct *curr;					/* the currently running task */
+    struct sched_array  *active;				/* pointer to the active priority
+												   array */
+    struct sched_array  *expired;				/* pointer to the expired
+											       priority array */
+    struct sched_array  arrays[2];				/* the actual priority arrays */
+	int best_expired_prio;						/* The highest priority that has
+												 * expired thus far */
+};
+
+/*----------------------- System Calls ------------------------------*/
+/* These calls are provided by the VM for your
+ * convenience, and mimic system calls provided
+ * normally by Linux
+ */
+void context_switch(struct task_struct *next); 
+unsigned long long sched_clock();
+
+/*------------------YOU MAY EDIT BELOW THIS LINE---------------------*/
+/*------------------- User Defined Functions -------------------------*/
+/*-------------These functions MUST be defined for the VM-------------*/
+void initschedule(struct runqueue *newrq, struct task_struct *seedTask);
+void killschedule();
+void schedule();
+void activate_task(struct task_struct *p);
+void deactivate_task(struct task_struct *p);
+void __activate_task(struct task_struct *p);
+void scheduler_tick(struct task_struct *p);
+void sched_fork(struct task_struct *p);
+void wake_up_new_task(struct task_struct *p);
+
+/*------------These functions are not necessary, but used----------------*
+ *------------by linux normally for scheduling           ----------------*/
+void enqueue_task(struct task_struct *p, struct sched_array *array);
+void dequeue_task(struct task_struct *p, struct sched_array *array);
+
+#endif
diff --git a/Proj2/schedule.o b/Proj2/schedule.o
new file mode 100644
index 0000000000000000000000000000000000000000..7ccdc6248c8bb844254431b20af5317d340e7930
GIT binary patch
literal 4712
zc$}q|UuYaf7{KTDlJ-oKdi|5q(x6KrArZ4&YA|;;giYeL3mS=qfJo%Bz1x^Gm%H?C
z&m`Jl;i#}Kg2e}4M1mmrqAyY?A|_Ppp`aqt7wN;j6c#IT)t5Yk#+lh~?&c;tM0DWp
z`{wt3^L_K}%+2h*m3;oZ5(**KLTC&%d(9R**wl6S?m``C#&GT#l|NL&S@#U5T-zij
zk9-+!(le?wn6K&)f;ZKMgOl7g+$qm+XRuTZXFP7W6A>(Rj69=qD^3SG)BQp}F7$OO
z-DT{zUSr8?Red(pP)9o&YP^F@$!RCP-+x1jXinVk)1s=$8jV&>dLZjWR+BrsxEXG{
zpG(JyNjbIq^CX2)@pRntNDfz@y|!gP>#Ol=TjkSKogO8ER+98!qW2#IuXD+r(ouhc
z$vQA6xkE$ydHBrdlC`p9RMzXro@6|ctlLi;Zny7*pJ`<)WH?y5>vecOV8aQV36)4Z
zi<au6cuBYMlHwVV57sMH-FuvlA`3=GPB#K6ehwvQJgFke!gxwE3-fShJi4SV-Vt<~
zGy$$(;c^jN_gw<Bw9F8DRrTqXQt=GEfEf~3H|C4gh<B<n9HC~U2--X8#%vlBuJ4I{
zv-xvyzN1@=BmQE!`lxg3m)}V!hi;2)e|O+soXbeK9)EXw7fb-~jygnC*h6A%uubSM
zW1Ial{=Kv4v40F|;Hqm0$N$Fg*M#+IHm_#$Sz81Bxoj?{q25df%2;OF&c1G`nL^&e
zzQ^J03B7R<g;t}XaOc6udw2pp$p4Ubn|zHQj=rr-b{zmlY@?t@CH7g+A4=?3K-VSq
z4?*vf*uUCm{9VvTCH5WA6B2t59N4|G`oTUWs~_w`viiY3D61drXJqy7W4{abkpMfo
zFgf{*+JE7NnE`cJ8`93IXJfH=Y$P_U_FuFzs$tqb9~_PkAf%PnmTdD9mUhvX3rs6o
zIa9N(RU2s;(>9TIsZ_$W;CHCiT1d?o%_R$I>B7>ImB+66f^BIy`(Vj7(~IbTHx(gz
zB_0sC4l>c!%7rdE9l%JNJM7C1#g~U5PXz2ILG}R;3*)Z@1r5mcB*gr$<A)%>A{qaL
zz{PiwG0FH(Vf?l*AR_oB0_H^95nn98c=G%XpuNw}2$&OT8?d07z(wB|CF6e*H-uz7
znWp&c`SIpH<Aa_ZY0DkH^uXAOKV4{V{f|iUztrW+u#hmQ)}TiG+R%gDAX``xB^)>t
z!h<(s7`5+Vq)r9LKL&O80q+K$0Ima9f!_e006qZxPvE^Rd4m@>OrK^D7k4c}!}xQQ
zdk(ijjw86&gmzxSry$O+5K0IBG9r8HuU(dz$ydOi<zq2l1AYhk4?&hBao&{7=N*W%
z2G5P%)gJ&q7H-a)w2vimK9}$t5N8hJ3<3WZ_;uie!0!P68u%ID_kh;~{x@(1w%iCy
zTuLuknR3q3(kPcL*(o!VL8(+jrAo%iF-BDKCd7uJ<+5EuOJ*)tNFytMxonlKlx>z4
zQSmZb#IH#W$A*$F7mMW1N*D6vnoE^dvUYj_ze#a}sdH++P-JQv$6rLt#cbZ5Z-gqQ
z>@21$=AxA<FQ@X>ia$D)qAz8p4bfVA@XFTc(+0;XBF78=>pKCGEIYZn=pQQFMmYW`
z$KU68l;fKmKf>`JguI>5|5=iER}yC}6wI%4{5Z!ylK6kY@otWPDe(_0!Tb{m?+rKk
zNsbSOTb~0v$45B-Q=I=8$N9Q8IL_z&jN|;e{3!ANP2&H6<2@YjX$y`s!0{6t*V<a^
zW&aJH;{5q_S5ecSzZZ3Zv-59G;OzXnDsXnbZU~&+Gg|^@_e@RT>|A6=KjZBFQ3cNK
iA6?+=9Gw$5I~T7CoSlms0%zyqmcZG$SQ9uq7ykj{nrssQ

literal 0
Hc$@<O00001

diff --git a/Proj2/schedule.old b/Proj2/schedule.old
new file mode 100644
index 0000000..02d4816
--- /dev/null
+++ b/Proj2/schedule.old
@@ -0,0 +1,217 @@
+/* schedule.c
+ * This file contains the primary logic for the 
+ * scheduler.
+ */
+#include "schedule.h"
+#include "macros.h"
+#include <stddef.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define NEWTASKSLICE (NS_TO_JIFFIES(100000000))
+
+/* Local Globals
+ * rq - This is a pointer to the runqueue that the scheduler uses.
+ * current - A pointer to the current running task.
+ */
+struct runqueue *rq;
+struct task_struct *current;
+
+/* External Globals
+ * jiffies - A discrete unit of time used for scheduling.
+ *			 There are HZ jiffies in a second, (HZ is 
+ *			 declared in macros.h), and is usually
+ *			 1 or 10 milliseconds.
+ */
+extern long long jiffies;
+
+
+/*-----------------Initilization/Shutdown Code-------------------*/
+/* This code is not used by the scheduler, but by the virtual machine
+ * to setup and destroy the scheduler cleanly.
+ */
+ 
+ /* initscheduler
+  * Sets up and allocates memory for the scheduler, as well
+  * as sets initial values. This function should also
+  * set the initial effective priority for the "seed" task 
+  * and enqueu it in the scheduler.
+  * INPUT:
+  * newrq - A pointer to an allocated rq to assign to your
+  *			local rq.
+  * seedTask - A pointer to a task to seed the scheduler and start
+  * the simulation.
+  */
+
+void initschedule(struct runqueue *newrq, struct task_struct *seedTask)
+{
+    printf( "Begin init.\n" );
+    struct sched_array* actual;
+
+    newrq->nr_running = 1;
+    newrq->nr_switches = 0;
+
+    actual = malloc( 2 *  sizeof( struct sched_array ) );
+    newrq->arrays[ 0 ] = actual[ 0 ];
+
+    newrq->active = &newrq->arrays[ 0 ];
+    INIT_LIST_HEAD( &newrq->arrays[ 0 ].array );
+
+    enqueue_task( seedTask, newrq->active );
+
+    //seedTask->need_reschedule = 1;
+
+    seedTask->first_time_slice = NEWTASKSLICE;
+    seedTask->time_slice = NEWTASKSLICE;
+
+    rq = newrq;
+}
+
+/* killschedule
+ * This function should free any memory that 
+ * was allocated when setting up the runqueu.
+ * It SHOULD NOT free the runqueue itself.
+ */
+void killschedule()
+{
+    printf( "Begin Kill.\n" );
+
+    //free( rq->arrays );
+
+}
+
+/*-------------Scheduler Code Goes Below------------*/
+/* This is the beginning of the actual scheduling logic */
+
+/* schedule
+ * Gets the next task with the shortest runtime(time slice) remaining
+ */
+void schedule()
+{
+    //printf( "Calling schedule\n" );
+
+    struct list_head* pos = NULL;
+
+    struct task_struct *task = NULL;
+    struct task_struct *next = current;
+    
+    unsigned int rem_time = -1;
+  
+    list_for_each( pos, &rq->active->array )
+        {
+        task = list_entry( pos, struct task_struct, run_list );
+        task->need_reschedule = 0;
+        if( task->time_slice < rem_time )
+            {
+            rem_time = task->time_slice;
+            next = task;
+            }	
+        }
+    if( current != next )
+        {
+	rq->curr = next;
+        rq->nr_switches++;
+        context_switch( next );
+        }
+}
+
+
+/* enqueue_task
+ * Enqeueus a task in the passed sched_array
+ */
+void enqueue_task(struct task_struct *p, struct sched_array *array)
+{
+    //printf( "Calling enqueue_task\n" );
+    list_add( &p->run_list, &array->array );
+    p->array = array;
+    rq->nr_running++;
+}
+
+/* dequeue_task
+ * Removes a task from the passed sched_array
+ */
+void dequeue_task(struct task_struct *p, struct sched_array *array)
+{
+    //printf( "Calling dequue_task\n" );
+
+    list_del( &p->run_list );
+    p->array = NULL;   
+    rq->nr_running--;
+}
+
+/* sched_fork
+ * Sets up schedule info for a newly forked task
+ */
+void sched_fork(struct task_struct *p)
+{	
+    printf( "Calling sched_fork\n" );
+
+    p->first_time_slice = current->first_time_slice / 2;
+    p->time_slice = p->first_time_slice;
+}
+
+/* scheduler_tick
+ * Updates information and priority
+ * for the task that is currently running.
+ */
+void scheduler_tick(struct task_struct *p)
+{	
+    p->time_slice--;
+    if( p->time_slice == 0 )
+    {
+        //printf( "A process has expired.\n" );
+        //dequeue_task( p, rq->active );
+        p->time_slice = p->first_time_slice;
+        p->need_reschedule = 1;
+        dequeue_task( p, rq->active );
+        //enqueue_task( p, rq->active );
+    }
+}
+
+/* wake_up_new_task
+ * Prepares information for a task
+ * that is waking up for the first time
+ * (being created).
+ * Also handles preemption, e.g. decides 
+ * whether or not the current task should
+ * call scheduler to allow for this one to run
+ */
+void wake_up_new_task(struct task_struct *p)
+{	
+    printf( "Calling wake_up_new_task\n" );
+
+    enqueue_task( p, rq->active );
+    p->need_reschedule = 1;
+}
+
+/* __activate_task
+ * Activates the task in the scheduler
+ * by adding it to the active array.
+ */
+void __activate_task(struct task_struct *p)
+{
+    enqueue_task( p, rq->active );
+}
+
+/* activate_task
+ * Activates a task that is being woken-up
+ * from sleeping.
+ */
+void activate_task(struct task_struct *p)
+{	
+    printf( "Calling activate_task\n" );
+    __activate_task( p );
+}
+
+/* deactivate_task
+ * Removes a running task from the scheduler to
+ * put it to sleep.
+ */
+void deactivate_task(struct task_struct *p)
+{
+    printf( "Calling deactivate_task\n" );
+
+    dequeue_task( p , rq->active);
+    printf( "deactive done\n" );
+}
diff --git a/Proj2/vmsched b/Proj2/vmsched
new file mode 100755
index 0000000000000000000000000000000000000000..4ad07001645e4f3f7d537247da82ade8c8380de8
GIT binary patch
literal 20452
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
GlK(eg+A!(>

literal 0
Hc$@<O00001

-- 
1.5.2.1


From 9405ae8a380c78207be5a181b16c62b05931ccdc Mon Sep 17 00:00:00 2001
From: CrawfordI <crawfoia@onid.orst.edu>
Date: Sun, 24 Oct 2010 11:12:14 -0700
Subject: [PATCH] Minor fix.

---
 Proj2/schedule.c |    6 +++---
 1 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/Proj2/schedule.c b/Proj2/schedule.c
index 9532349..0d4b35d 100644
--- a/Proj2/schedule.c
+++ b/Proj2/schedule.c
@@ -154,7 +154,7 @@ void dequeue_task(struct task_struct *p, struct sched_array *array)
 void sched_fork(struct task_struct *p)
 {	
     //printf( "Calling sched_fork\n" );
-    printf( "%d\n", sched_clock() );
+    //printf( "%d\n", sched_clock() );
     p->first_time_slice = current->first_time_slice / 2;
     p->time_slice = p->first_time_slice;
 }
@@ -166,7 +166,7 @@ void sched_fork(struct task_struct *p)
 void scheduler_tick(struct task_struct *p)
 {	
     p->time_slice--;
-    if( p->time_slice == 0 )
+    if( p->time_slice <= 0 )
     {
         p->need_reschedule = 1;
     }
@@ -216,5 +216,5 @@ void deactivate_task(struct task_struct *p)
     //printf( "Calling deactivate_task\n" );
     p->need_reschedule = 0;
     dequeue_task( p , rq->active);
-    printf( "deactive done\n" );
+    //printf( "deactive done\n" );
 }
-- 
1.5.2.1


From 04eb4e862f456d02889715df202721f739c50fff Mon Sep 17 00:00:00 2001
From: CrawfordI <crawfoia@onid.orst.edu>
Date: Sun, 24 Oct 2010 11:20:11 -0700
Subject: [PATCH] Added newline to end of file

---
 Proj2/cpu.c            |    3 ++-
 Proj2/macros.h         |    3 ++-
 Proj2/privatestructs.h |    3 ++-
 3 files changed, 6 insertions(+), 3 deletions(-)

diff --git a/Proj2/cpu.c b/Proj2/cpu.c
index 5b8c529..6a463ae 100644
--- a/Proj2/cpu.c
+++ b/Proj2/cpu.c
@@ -609,4 +609,5 @@ static void cleanuptask(struct thread_info *p)
 			free(temp->processName);
 		free(temp);
 	}
-}
\ No newline at end of file
+}
+
diff --git a/Proj2/macros.h b/Proj2/macros.h
index cd48fd9..a532fff 100644
--- a/Proj2/macros.h
+++ b/Proj2/macros.h
@@ -9,4 +9,5 @@
 #define JIFFIES_TO_NS(TIME) ((TIME) * (1000000000 / HZ))
 #define NS_TO_JIFFIES(TIME) ((TIME) / (1000000000 / HZ))
 
-#endif
\ No newline at end of file
+#endif
+
diff --git a/Proj2/privatestructs.h b/Proj2/privatestructs.h
index 197750a..95ea24b 100644
--- a/Proj2/privatestructs.h
+++ b/Proj2/privatestructs.h
@@ -31,4 +31,5 @@ struct thread_info
 	struct list_head clist;
 };
 
-#endif
\ No newline at end of file
+#endif
+
-- 
1.5.2.1


From ad0eb003c32ed4124e893e6e97eabbce5611b7c4 Mon Sep 17 00:00:00 2001
From: CrawfordI <crawfoia@onid.orst.edu>
Date: Sun, 24 Oct 2010 12:19:00 -0700
Subject: [PATCH] Changed time slices in sched_fork()

---
 Proj2/schedule.c |    7 ++++---
 1 files changed, 4 insertions(+), 3 deletions(-)

diff --git a/Proj2/schedule.c b/Proj2/schedule.c
index 0d4b35d..b2e6016 100644
--- a/Proj2/schedule.c
+++ b/Proj2/schedule.c
@@ -105,6 +105,7 @@ void schedule()
 	    {
    	   	if( task->time_slice <= 0 )
 		{
+                    task->first_time_slice = NEWTASKSLICE;
 		    task->time_slice = task->first_time_slice;
                     task->need_reschedule = 1;
 		}
@@ -153,9 +154,9 @@ void dequeue_task(struct task_struct *p, struct sched_array *array)
  */
 void sched_fork(struct task_struct *p)
 {	
-    //printf( "Calling sched_fork\n" );
-    //printf( "%d\n", sched_clock() );
-    p->first_time_slice = current->first_time_slice / 2;
+    int new_slice = current->first_time_slice / 2;
+    rq->curr->first_time_slice = new_slice;
+    p->first_time_slice = new_slice;
     p->time_slice = p->first_time_slice;
 }
 
-- 
1.5.2.1


From 8293f93956cd3428bb93aa90e23d3850e12761d6 Mon Sep 17 00:00:00 2001
From: ClisbyS <clisbys@onid.orst.edu>
Date: Sun, 24 Oct 2010 12:36:40 -0700
Subject: [PATCH] Minor change to wake_up_task

---
 Proj2/schedule.c |    9 ++++++---
 Proj2/schedule.o |  Bin 4712 -> 4528 bytes
 Proj2/vmsched    |  Bin 20452 -> 20452 bytes
 3 files changed, 6 insertions(+), 3 deletions(-)

diff --git a/Proj2/schedule.c b/Proj2/schedule.c
index b2e6016..d31ba1b 100644
--- a/Proj2/schedule.c
+++ b/Proj2/schedule.c
@@ -183,9 +183,12 @@ void scheduler_tick(struct task_struct *p)
  */
 void wake_up_new_task(struct task_struct *p)
 {	
-
-    enqueue_task( p, rq->active );
-    p->need_reschedule = 1;
+    __activate_task( p );
+    //enqueue_task( p, rq->active );
+    if( current->time_slice >= p->time_slice )
+    {
+        p->need_reschedule = 1;
+    }
 }
 
 /* __activate_task
diff --git a/Proj2/schedule.o b/Proj2/schedule.o
index 7ccdc6248c8bb844254431b20af5317d340e7930..16173b5837e7aceb4b35633d5653ceb296c48880 100644
GIT binary patch
delta 944
zc${^S&ubGw6oB__Hp%YBq)D{dZb3|A38@evr%hpPVlc4v(iHJ*p!oxAK?<VSgN24g
zXn2SPFR2Ihq8RGIQz=0xfnMTOkkZp$6g>zEDRDOQVzz-U%&+fzZ)SF$GyCD{b_SBI
zxir8kRv@7*S$5g6i}}ri2WfYDSTt2Z5O59d1SU2g_WS+4Luf$0{@Af>KQn?|G`mi{
z+@qysSCV$QS1+0N-JZKcy<!gb<O9C+-NNgVa*^j&@(liA=gqg*Lio$~2-l^{_*SZk
zVZez08<g<7zW@ei1NR`i_blK8xPgtJp~w+o@D;HeG{g-FbHM~A<;-wel{3nQ#ABwg
zAseuR9l0P{QB;)$*v3VrAnpeSu}vid``A$mN>$|<pD?Bx%2b%IezN>4cwgPoQz9p6
zJ_wVni2?`~&V)4mGue5vb7W6(IrIij@Na0z{jb{>7M^TTs7awOSc|jJl#j1V#9tAw
z5zi5C5r0nHAl@c^L_9_O3-KSEPyZLkB%<_ISzHdk$9QBBtC0hEiZc_M-URO4J6~e0
z*XQ56fo*&2q{nt#3vq0*{^Ov}Vl1lVOy4Lz=81pp;nQbMVOjdubFv(~$!!0e+-tZS
z)xw4}vI+bhUC~eI&P{p+m23)EW14P>qqp(eE!>Tbs+@$g_7uC!4hvWvvo(acrVq>2
T9J5E5i)%?Lj&M9?hqd_!DRjt3

delta 1103
zc${^TPiPZC6vlTpn`Aft)7Y+SBid?8B19TItkKxCv_g6)4S4a^h9t$Jv{jozAwi3H
z2)QJ@LvJ<;q9?J0K;uDE5pNcP=s{5GL5Ly+@zR4<XR~k3HrRogxAXnJH@umBPfs*Y
z7X4&!JupDX48%!~Z7f!}*end6y<5-pLXKQwGx^GUQX->wzPn=i-0lWLM^jm1`PVO$
zs8b3?B@~7u`In7v^q}2*Jfehx8eq*Z21mFq80C6tOc-1Fu*CIyd?^c)N+*(wvrFmY
zsrk7y)mOPRyT`yD_lZovM`M%(;izef$d#PQKu8!?%(5`;U|ORLn`W8Ka?oe)0T=Jr
zKI6P!$a1RZ6s+(vc?>l^3TuK9e)H!^8Nx!8-7>YzMZr(Dpe96x1&f-}1Y(i9FWc3f
zfiUd>eS!#s=0i~AImlYFl805n02;dKWEsMQ!EF_#D$+300MZ>8u|6Vi;j490x$HUH
zP+%FY5wxz-*+s1$gSwwU{Q<07Me;;hZ&lGVjh+yCUZGw>J&5`{)Ssi?kNOwXw>$Ko
zsI&N%vi1x&lULHI3>>qU?NiBX^U15s!j0Lv#TlsCCtF@HJ2s_dd^zQ2ZaRPcQAY_r
zJ4ET;0ki^crzkx;fEr-LDUyfEI_@*HJ%@FkAnMBRG$L!2uk%Yf{}5cKXO^Mi6k)?@
zv%7TcjiQc!&}HiB51sDS>0a*t)dwKt5`Cw+{q=dVzB9Tk2V8I^X@}f*iT`@6&b0Fs
vDGUutwZ>t{ep&_M7Ns4e!yVKEAxgEzx!plakf2m+lX?f;hLT(4wWjzBO9||7

diff --git a/Proj2/vmsched b/Proj2/vmsched
index 4ad07001645e4f3f7d537247da82ade8c8380de8..17bb56b32fb12efcdd5b83b0f6c64b860573d4aa 100755
GIT binary patch
delta 1096
zc${_9Ur19?90&08n@(J1uF}?MwLe;!pzDvMBa7>7^M*wR>kmkT;6uGsiiw${2kFna
zfz@x(OAtW>fiHD?D2y_bLg=Bu7pVu8s9TvXS~*KSeQ%TMp$?q;IcMkmzMOlwdvlH6
zT%!vwY#n~_t94u)dbFs!C_U*eQqt<T$hCxO^rv~XM7wzL(ogj9jw5KD_c}`mRf`%%
zn0L4&J=S-usL7yOj(bj06WhH@9lKO5WN1po>E7e3&EYepavmaigSRH^S?oczQlxGU
z4d<S2mr|;o(S&HJRyFJNBCG{MiIz>OmOp7uv|zT{*-L5+YSDxtzhb|Z|B8FODqZ4C
z-*rmxO<!|GENUR&sNEwprShc_3r%Bs$Zkf|d9=`UELf@SnKlm-tE>EVyfj>2u+0@s
z89rgYlyxE(0d*BvN#Xo~zUKLSyTG+@AlD2!R)jO8jBos^plV6`-#_h~m2%*TzNPR;
z<|#qTGdAxhA&Sjg9G0>L<MI(H<FIv9%DXW2R?0!>ekWxT9)x)oA<n`w*k(u>f$DqI
z!+{T|hgZf>4<EuoI17`oXB_nzLL|peApisC1Oi|%fdIG{#$oSg1i+pz2!MS_1i<6C
z*t|?33csNq9)S_q4_jbl67|rTLOomy2jQkE)WcSoXBFb=0SwA8cnu?P*>?oM-7pSY
z;azwS4#M{^2|Yg$fG;Zu%U~mnz&Jb)Z@?Q_`pV)n87p#dW1?!I{fwnLCoBEg3K#lS
zyvQg&E^(8ONAOgcO5Jphy?FL>6`nKPQ0n&j3KS6(|IX;Z%QW(J?7ECy<^S3B0K1;^
z2olGc{BEngP!T1(%D>SmaFG`Arxl`?p{KaX-^IhU?9MvHMkl!{;J5w$ukndMxh=am
zJ<Hbb2d-pNH}Br+plto{)=8o^y+PS$ar%7eEvx6k$IvZefl&En(BbT#TMf*u)>C?Q
zhN*hOW**UOB|KHVhMw!*ZAUG*n~PzG&Abn@1^IS(4UO_pxXX5V?zeJos_C-ikZw^+
Ri5hwRc0Y~l4cj}jegYd|e-How

delta 1077
zc$`hsTSyd97zglkMn_t^xVf5ZChn@`X1H4vxl0z~dK=N8=pnmMSsL`vT|+4`Sb~<N
zT=|52tDeg4ISBfqOHp7DBt4`L!B$eEm~ND{6?poOBh`U3zjOP(Ip^%`_;o&horhmp
zx;$*YbajpmEswa&PQ;~{YCU|Fjr+9cX*HbJQ0j`${B3WBUrv6R#F!dt({(@9t`c0+
zYO|{ncnNhm&hw*Wb*@-au7)b~km9`*Y0jdp&MN=9R0l#7m%61Q+8k5^Z86qVriSFj
z#<;H{*0fm-r6<iV@-I>Y5v~Sds4b>1`z{3LCh3J!U3PQ1u|hHzNK~3`CvWZrE~qc}
zOj%&css`KQ{l@0?XR`<kJ|DV^)0iXK<3=L+fYrf5N=fj^$Rsuy5AG;22$|5qymG6Y
zXf@t)%7ypG_1rn)`PnJ*o0R_sXK5m@)Oq>;q1rhih92T=`i2ie3_lH{Xj}77B(|?^
zNM;R<^+%eHoojS7oIKHJY=>thY}wBlD@40HDntv~dGCbihKJt^(GSNz3NZ>7e-a`N
zYoJ|X>@4)c23?3cxM>3Mux}FaFffI9cn6M3?Tk&L5y!x-X(UKsEDF6)o<RcWjv)c`
z!)|!*3lhLvUy%Sl_=b2`k4v>DGG@hZ;)Q!*9ee~^pz;IpP>v%Wro+*8G;BYS0Pccz
znXy*rg#)k-&cYVx{)Gf^7wm^O;3yn{aX1I<`1%~b5fA;a4qk*|7>2i#%<nkOglX2o
z3klL3qpL+L`D^Ma%HcK|#?wa=c(#(oox}TREuPa<?aq;Hc?#Q3$K6@{5CzfiM8Amc
zqd!Q)SQVuSj7s?mE2gEMjhQ-bM`Hg<KI$gaDDCld^sZMd{0f!&JeI$IENb-?TO5UE
z&!G+Yt|jsa?cA2Z9on&NKR6F-^~!E3)0S&4S+kIM3RPlDn2$#M8JT?xv%ZDdecYU#
zCSEpUF}7!vV)|KDzy~#F`AG?9?X1kO80Ry}c6wY{fEyXB?67n$j1|%8st#P1CaG?Y
P^KYp3@TgW_9Z32E8vlvd

-- 
1.5.2.1


From 4e2eeaf2f3d63308c625ef86e12bda8b10740a41 Mon Sep 17 00:00:00 2001
From: thommatt <baddack@gmail.com>
Date: Sun, 24 Oct 2010 17:06:22 -0700
Subject: [PATCH] Cleaned up, fixed some values,  added comments

---
 Proj2/schedule.c |    8 ++++----
 Proj2/schedule.o |  Bin 4528 -> 4552 bytes
 Proj2/vmsched    |  Bin 20452 -> 20452 bytes
 3 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/Proj2/schedule.c b/Proj2/schedule.c
index d31ba1b..6d98340 100644
--- a/Proj2/schedule.c
+++ b/Proj2/schedule.c
@@ -2,6 +2,8 @@
  * This file contains the primary logic for the 
  * scheduler.
  */
+//CS 411 Project 2
+//Matt Thomas, Sarah Clisby, Matt Martinson, Ian Crawford
 #include "schedule.h"
 #include "macros.h"
 #include <stddef.h>
@@ -49,7 +51,7 @@ void initschedule(struct runqueue *newrq, struct task_struct *seedTask)
     printf( "Begin init.\n" );
     struct sched_array* actual;
 
-    newrq->nr_running = 1;
+    newrq->nr_running = 0;
     newrq->nr_switches = 0;
 
     actual = malloc( 2 *  sizeof( struct sched_array ) );
@@ -76,9 +78,8 @@ void initschedule(struct runqueue *newrq, struct task_struct *seedTask)
 void killschedule()
 {
     printf( "Begin Kill.\n" );
-
     //free( rq->arrays );
-
+    //free( rq->arrays );
 }
 
 /*-------------Scheduler Code Goes Below------------*/
@@ -184,7 +185,6 @@ void scheduler_tick(struct task_struct *p)
 void wake_up_new_task(struct task_struct *p)
 {	
     __activate_task( p );
-    //enqueue_task( p, rq->active );
     if( current->time_slice >= p->time_slice )
     {
         p->need_reschedule = 1;
diff --git a/Proj2/schedule.o b/Proj2/schedule.o
index 16173b5837e7aceb4b35633d5653ceb296c48880..37ecbb6f512d3ba797b220afb1c34eab1c817cb3 100644
GIT binary patch
delta 954
zc${^TJxBvF6vyxNitSyk?VTU-bn&A|3!-#73u>((_%REPDyY<<f;i}8yNKvu%Nx45
zs6*XUgi1FDQ9%(qIl1YelZ%5O)YN;`c-TOa%kTG3NVs?0dEJ=~LUSh62U2D>Cy#Cq
zoT{)Q`-bNh;)%9+BEHfi@rGIF2<WGe&I1QTG37F$4GXR-sKu1qgftf1QJBULK5k+}
zi8}H%*zRh=v=W3o7L=$mrApuJ9zivgpx0WxV@y3W0uF1{Wld5e?+yv1anwA_xFj1P
z8zNi6m?sBM_~J1Yo!lax@EuG1OXrCPqF%7(RgBd#NR~6}JCxa?)B7pAOFST3>tW(K
z;`7AA#Ph_n#7*K?#P5iA5Pz_Ei}Yp_&$K~D#k(fYFVA7pyU8zyuDUh2#gjTVR-|b8
z%JsZ|maGQw%Qb;-RN?!m`PkS|6?-A@CV}5n$v0rk$M|37qtPq>W*UXeAQpWrd??sf
z!5&rF^;q6D`6^hy_-g0>r*#Wlyk|t<3<vxZMx{QIG^=EvaL><vs`A`s$Faz5rEVnn
mYcCNrW|YVd*=zvA+*WERX|q|J;kHsS=QjI>8I8Ghdc_xu-pMln

delta 862
zc${^TJxIeq6vy-0icM?USU=7<#p<AfLZ&Dv6+tNI>aL<lMTDY*;vj;Eh@j;mb*vxQ
zNwCzxNwEliAc#UIm+Issb`&i2(!A0b^x)mg`~Uv$a=FWG>uKvwJE*aa9)Q?H5-!s<
zu;5e#VQ^|XGN(r7A`9L0JRF&w?Z$1_5XkAQ>(BxHxKyo!8&lOc(1hcjI^1%%!5*gE
zAqZoh&pW7zA-KS3X-<hDam*u>#yNh8y4WO{)n}=D#B&5e%zKy;c9{BrnFN)GLjd6#
zTf7Vk*y~Ng8@_t=7MUC~JObR2rCI_r&tsl<EaR1zt!$EKgI4b&Z=Cd?)2s(cKOlXQ
zbdB^B>AR%sq-RKfAU#O>v#B==A2yJq1{oD;3FFc_s=h_-o~UtBRXl2_exz*d-pAv+
zNCQ`W4A$_~$CLzAJoOgONr`4Gw828}3<?2^`Wc)Vv(n}Kd!0Vq_cQI-LYu8``KRl}
z=z@0ynJLA8dOJ~*nWVcav=K+;VaVb>?|P%1CoE@Uc!KyOSALhAjcy>+GUb}63cqOq
gHBQTyK4znnIL>MLiW4^afU#PpmhUrXqcVNP51)^$?EnA(

diff --git a/Proj2/vmsched b/Proj2/vmsched
index 17bb56b32fb12efcdd5b83b0f6c64b860573d4aa..aa97152b78865a68f23bd09fea49d6b4503679b7 100755
GIT binary patch
delta 933
zc$_`bO-NKx6bJBoo*y_8sZ%zJmE$L7=(9!X;Me&5##9o5q=K}CAt74KVv<BkTTE}E
zb_(4o2$C%#d<3>C5ELau7vcyJRzjosF;eDeAGg1b^x&P}z1(xoyZ3RI2WWYKdS*>d
zRUACd-o>|3gK2@uV46LkF+$%WsF0sU4O737XLc*(FeZ*)B&uceiFH~ZwG@Yhe+(5u
z)7!mXjjK*d8aJv=%_}50(Rzof`Kk51Nz?N^W~=ai;aRInLr)UA%1>ji>Gm`&w`?im
zQJa)f>umQ4XNjhV>_uVCR_1eF(Ddl-{fS;2rggp}%?<T-pZCu;^7ZINo=(t?_8ep=
zfdqw%qGLEG@jh+v>qJ*%bEH-1_PjZ-yX-ewH*$VbE3Na(qzszm4@ou0ToL=#t!e1%
z_g4Rva%$WtOs)^^5EK`bd!2+x$FCS$lG257$tNlM;ls~Tj=|usQhMN7=!dsqj3NZX
z9N6WRvJPHeK|P#bMLir^Lp_{^9vHrkdN{d(`XGF8vjYt<NZCXKSmQ$jcoX)+_giQH
zC%>ZsocVzU@B#izOt27HKT!|cU>%%=E?B>VdYIxzJ<Nt4Sh|aP*ac%kgm}?_K@JA1
zunwl~p#i)B`(YOxgA>pLcc33;{z3!Xh)XaB-i38=5ca@V@OkL|^)f=!8-vKq%^7jD
z!0wEATILbNWS&B-<Q2rnY|4zM2|j};*^#-w+JxB1Zp1zwL7d?!L?5ppn%SggQy3Si
z7Da6HRdtw`C~P##ZlV@0vZ<#3cbo6ovP~jAFcZcbTVF5@a&3Wygwa&6L)2<C*smzD
z$%%oK)Ig$G!>foRqLSx|EwK}atG2_{YZO?OOeLGx%~pv@Ge$ybi-M!{mRqp>k#ZFW
iT`cd$_M0lYX~Ed7$R?cVoI}Ma8XULCY)m=gLjM6g8Dvuc

delta 946
zc$`Jje@IhN6bJBoo<EvVIc2t%irbW!g05gGL({pXKG6zeRL~zKST+zfFfmg^`Y8+4
z?#zDz5lj&LBYZ-IkXaH4{*j@7ND?YiGfgM0)KYKXHK_;peD34CbN0^LUFf2PE^2!p
z(O_nOuZH&N;i!I7@TT8n3##<dQY4+=9Z|jXSjmcRk*Gj<rzs*j!=n#=qoo0@J#6nx
zIAgNA(d*6U#c_g0l;Zd)iHIBZ*Qtnm^vCxMccG)VgMZMQ=_!{CcT)7xdeqoVa%SFa
z<lTB9gnYZv$7&q1J8UZoIcuJ;CS7*Ntn+6EjY|B$1MZlQeB2<@BOYVyCLe!ptW#I1
z^~`O{n((&dZK3oU&q=JNRsJk7mB#p|#M3eLk%1qoHsJ*~yr*`A7<=2+rsO1D4sEhu
zDR))si(C~IX^c^9Nah7%EG01atPnNWXUqxVfwl8O48o1iLQKMhFGBd?C8&`YyALg}
z&MSly%8RInV_#7ZJC{)pU%^SZ1N~AHV?!%w5W<)rTA*$f4WQkJ2Jjs8z}IVN0EfP#
z0es^}19$_UMH9+c(ofXGO6Y{6um(EUQ4e(+sE5gL5~gpW-i1vqHkvTTo<Iwnflhen
z7aG74=z+Cx5Wawua1r{U{x|CJ_uHWbmO&@<z=yC0_Jk`t$yY<-)qx|Gdq90pa_kQe
z9yAsgIC>aliZ`bw&^+%(H1ZKdna?3U;FOj?quhYF&2!TN*;2$Z-i+A6yAj9v2;vH#
zLsWAzXB=kuEE4;FC1F{xHvIgoxp&~GErM?GT&p?a-$Ca$tr-!jl;E98d1>torG8$L
zttFM>%3dd`Q%Y^;C7sb2eB{V(=VdI3?PD^ZuxoXryIJdQ_96wd+ngM$c(*l&nZ^~v
u$tnqhwdZRwOkchkV^8O|Vi;FJD@`ez1sR0-juo0QQ)yv2sg<$9*ziBj+hPC!

-- 
1.5.2.1


From 1696cbc9b56afa6d34cf3568709146918f2296e9 Mon Sep 17 00:00:00 2001
From: CrawfordI <crawfoia@onid.orst.edu>
Date: Tue, 2 Nov 2010 16:13:47 -0700
Subject: [PATCH] Verifying branch

---
 test |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)
 create mode 100644 test

diff --git a/test b/test
new file mode 100644
index 0000000..cd719a9
--- /dev/null
+++ b/test
@@ -0,0 +1 @@
+Verifying branch
-- 
1.5.2.1


From 594368ada3e46f41284baf255d26a3135b02bec2 Mon Sep 17 00:00:00 2001
From: CrawfordI <crawfoia@onid.orst.edu>
Date: Thu, 4 Nov 2010 15:14:17 -0700
Subject: [PATCH] Replacing config file with version from kernel installation guide

---
 linux-2.6.34.7/.config |  989 ++++++++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 989 insertions(+), 0 deletions(-)
 create mode 100644 linux-2.6.34.7/.config

diff --git a/linux-2.6.34.7/.config b/linux-2.6.34.7/.config
new file mode 100644
index 0000000..a52a00b
--- /dev/null
+++ b/linux-2.6.34.7/.config
@@ -0,0 +1,989 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.23.17
+# Sat Apr  3 23:53:23 2010
+#
+CONFIG_X86_32=y
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CMOS_UPDATE=y
+CONFIG_CLOCKSOURCE_WATCHDOG=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_SEMAPHORE_SLEEPERS=y
+CONFIG_X86=y
+CONFIG_MMU=y
+CONFIG_ZONE_DMA=y
+CONFIG_QUICKLIST=y
+CONFIG_GENERIC_ISA_DMA=y
+CONFIG_GENERIC_IOMAP=y
+CONFIG_GENERIC_BUG=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_ARCH_MAY_HAVE_PC_FDC=y
+CONFIG_DMI=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION="-dev"
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_BSD_PROCESS_ACCT=y
+# CONFIG_BSD_PROCESS_ACCT_V3 is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_USER_NS is not set
+# CONFIG_AUDIT is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_CPUSETS is not set
+CONFIG_SYSFS_DEPRECATED=y
+# CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_ANON_INODES=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+CONFIG_RT_MUTEXES=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+CONFIG_STOP_MACHINE=y
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+CONFIG_BLK_DEV_BSG=y
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+
+#
+# Processor type and features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_SMP=y
+CONFIG_X86_PC=y
+# CONFIG_X86_ELAN is not set
+# CONFIG_X86_VOYAGER is not set
+# CONFIG_X86_NUMAQ is not set
+# CONFIG_X86_SUMMIT is not set
+# CONFIG_X86_BIGSMP is not set
+# CONFIG_X86_VISWS is not set
+# CONFIG_X86_GENERICARCH is not set
+# CONFIG_X86_ES7000 is not set
+# CONFIG_PARAVIRT is not set
+# CONFIG_M386 is not set
+# CONFIG_M486 is not set
+# CONFIG_M586 is not set
+# CONFIG_M586TSC is not set
+# CONFIG_M586MMX is not set
+CONFIG_M686=y
+# CONFIG_MPENTIUMII is not set
+# CONFIG_MPENTIUMIII is not set
+# CONFIG_MPENTIUMM is not set
+# CONFIG_MCORE2 is not set
+# CONFIG_MPENTIUM4 is not set
+# CONFIG_MK6 is not set
+# CONFIG_MK7 is not set
+# CONFIG_MK8 is not set
+# CONFIG_MCRUSOE is not set
+# CONFIG_MEFFICEON is not set
+# CONFIG_MWINCHIPC6 is not set
+# CONFIG_MWINCHIP2 is not set
+# CONFIG_MWINCHIP3D is not set
+# CONFIG_MGEODEGX1 is not set
+# CONFIG_MGEODE_LX is not set
+# CONFIG_MCYRIXIII is not set
+# CONFIG_MVIAC3_2 is not set
+# CONFIG_MVIAC7 is not set
+CONFIG_X86_GENERIC=y
+CONFIG_X86_CMPXCHG=y
+CONFIG_X86_L1_CACHE_SHIFT=7
+CONFIG_X86_XADD=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_X86_PPRO_FENCE=y
+CONFIG_X86_WP_WORKS_OK=y
+CONFIG_X86_INVLPG=y
+CONFIG_X86_BSWAP=y
+CONFIG_X86_POPAD_OK=y
+CONFIG_X86_GOOD_APIC=y
+CONFIG_X86_INTEL_USERCOPY=y
+CONFIG_X86_USE_PPRO_CHECKSUM=y
+CONFIG_X86_TSC=y
+CONFIG_X86_CMOV=y
+CONFIG_X86_MINIMUM_CPU_FAMILY=4
+CONFIG_HPET_TIMER=y
+CONFIG_NR_CPUS=8
+CONFIG_SCHED_SMT=y
+CONFIG_SCHED_MC=y
+# CONFIG_PREEMPT_NONE is not set
+CONFIG_PREEMPT_VOLUNTARY=y
+# CONFIG_PREEMPT is not set
+CONFIG_PREEMPT_BKL=y
+CONFIG_X86_LOCAL_APIC=y
+CONFIG_X86_IO_APIC=y
+# CONFIG_X86_MCE is not set
+# CONFIG_VM86 is not set
+# CONFIG_TOSHIBA is not set
+# CONFIG_I8K is not set
+# CONFIG_X86_REBOOTFIXUPS is not set
+# CONFIG_MICROCODE is not set
+# CONFIG_X86_MSR is not set
+# CONFIG_X86_CPUID is not set
+
+#
+# Firmware Drivers
+#
+# CONFIG_EDD is not set
+# CONFIG_DELL_RBU is not set
+# CONFIG_DCDBAS is not set
+# CONFIG_DMIID is not set
+CONFIG_NOHIGHMEM=y
+# CONFIG_HIGHMEM4G is not set
+# CONFIG_HIGHMEM64G is not set
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_3G_OPT is not set
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_2G_OPT is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+# CONFIG_X86_PAE is not set
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_ARCH_POPULATES_NODE_MAP=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_SPARSEMEM_STATIC=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_RESOURCES_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_NR_QUICK=1
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_MATH_EMULATION is not set
+# CONFIG_MTRR is not set
+CONFIG_IRQBALANCE=y
+CONFIG_SECCOMP=y
+# CONFIG_HZ_100 is not set
+CONFIG_HZ_250=y
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=250
+# CONFIG_KEXEC is not set
+CONFIG_PHYSICAL_START=0x100000
+# CONFIG_RELOCATABLE is not set
+CONFIG_PHYSICAL_ALIGN=0x100000
+# CONFIG_HOTPLUG_CPU is not set
+# CONFIG_COMPAT_VDSO is not set
+
+#
+# Power management options (ACPI, APM)
+#
+# CONFIG_PM is not set
+CONFIG_SUSPEND_SMP_POSSIBLE=y
+CONFIG_HIBERNATION_SMP_POSSIBLE=y
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+
+#
+# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+#
+CONFIG_PCI=y
+# CONFIG_PCI_GOBIOS is not set
+# CONFIG_PCI_GOMMCONFIG is not set
+# CONFIG_PCI_GODIRECT is not set
+CONFIG_PCI_GOANY=y
+CONFIG_PCI_BIOS=y
+CONFIG_PCI_DIRECT=y
+CONFIG_PCIEPORTBUS=y
+CONFIG_PCIEAER=y
+CONFIG_ARCH_SUPPORTS_MSI=y
+CONFIG_PCI_MSI=y
+# CONFIG_HT_IRQ is not set
+CONFIG_ISA_DMA_API=y
+# CONFIG_ISA is not set
+# CONFIG_MCA is not set
+# CONFIG_SCx200 is not set
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+# CONFIG_HOTPLUG_PCI is not set
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+
+#
+# Wireless
+#
+# CONFIG_CFG80211 is not set
+# CONFIG_WIRELESS_EXT is not set
+# CONFIG_MAC80211 is not set
+# CONFIG_IEEE80211 is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=m
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+# CONFIG_MTD is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=8192
+CONFIG_BLK_DEV_RAM_BLOCKSIZE=1024
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MISC_DEVICES is not set
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_SCSI_PROC_FS is not set
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+CONFIG_SCSI_SPI_ATTRS=y
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_LOWLEVEL is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+CONFIG_FUSION=y
+CONFIG_FUSION_SPI=y
+# CONFIG_FUSION_FC is not set
+# CONFIG_FUSION_SAS is not set
+CONFIG_FUSION_MAX_SGE=128
+# CONFIG_FUSION_CTL is not set
+# CONFIG_FUSION_LOGGING is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_FIREWIRE is not set
+# CONFIG_IEEE1394 is not set
+# CONFIG_I2O is not set
+# CONFIG_MACINTOSH_DRIVERS is not set
+CONFIG_NETDEVICES=y
+# CONFIG_NETDEVICES_MULTIQUEUE is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_ARCNET is not set
+# CONFIG_PHYLIB is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_NET_TULIP is not set
+# CONFIG_HP100 is not set
+CONFIG_NET_PCI=y
+CONFIG_PCNET32=y
+# CONFIG_PCNET32_NAPI is not set
+# CONFIG_AMD8111_ETH is not set
+# CONFIG_ADAPTEC_STARFIRE is not set
+# CONFIG_B44 is not set
+# CONFIG_FORCEDETH is not set
+# CONFIG_DGRS is not set
+# CONFIG_EEPRO100 is not set
+# CONFIG_E100 is not set
+# CONFIG_FEALNX is not set
+# CONFIG_NATSEMI is not set
+# CONFIG_NE2K_PCI is not set
+# CONFIG_8139CP is not set
+# CONFIG_8139TOO is not set
+# CONFIG_SIS900 is not set
+# CONFIG_EPIC100 is not set
+# CONFIG_SUNDANCE is not set
+# CONFIG_TLAN is not set
+# CONFIG_VIA_RHINE is not set
+# CONFIG_SC92031 is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+# CONFIG_TR is not set
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+# CONFIG_WAN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NET_FC is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_PCIPS2 is not set
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+CONFIG_FIX_EARLYCON_MEM=y
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_JSM is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_WATCHDOG is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+# CONFIG_SONYPI is not set
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+# CONFIG_MWAVE is not set
+# CONFIG_PC8736x_GPIO is not set
+# CONFIG_NSC_GPIO is not set
+# CONFIG_CS5535_GPIO is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_HANGCHECK_TIMER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+CONFIG_DEVPORT=y
+# CONFIG_I2C is not set
+
+#
+# SPI support
+#
+# CONFIG_SPI is not set
+# CONFIG_SPI_MASTER is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_SM501 is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_DVB_CORE is not set
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_SYS_FOPS is not set
+CONFIG_FB_DEFERRED_IO=y
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_CIRRUS is not set
+# CONFIG_FB_PM2 is not set
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_ARC is not set
+# CONFIG_FB_ASILIANT is not set
+# CONFIG_FB_IMSTT is not set
+# CONFIG_FB_VGA16 is not set
+CONFIG_FB_VESA=y
+# CONFIG_FB_HECUBA is not set
+# CONFIG_FB_HGA is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_NVIDIA is not set
+# CONFIG_FB_RIVA is not set
+# CONFIG_FB_I810 is not set
+# CONFIG_FB_LE80578 is not set
+# CONFIG_FB_INTEL is not set
+# CONFIG_FB_MATROX is not set
+# CONFIG_FB_RADEON is not set
+# CONFIG_FB_ATY128 is not set
+# CONFIG_FB_ATY is not set
+# CONFIG_FB_S3 is not set
+# CONFIG_FB_SAVAGE is not set
+# CONFIG_FB_SIS is not set
+# CONFIG_FB_NEOMAGIC is not set
+# CONFIG_FB_KYRO is not set
+# CONFIG_FB_3DFX is not set
+# CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_VT8623 is not set
+# CONFIG_FB_CYBLA is not set
+# CONFIG_FB_TRIDENT is not set
+# CONFIG_FB_ARK is not set
+# CONFIG_FB_PM3 is not set
+# CONFIG_FB_GEODE is not set
+# CONFIG_FB_VIRTUAL is not set
+
+#
+# Console display driver support
+#
+CONFIG_VGA_CONSOLE=y
+CONFIG_VGACON_SOFT_SCROLLBACK=y
+CONFIG_VGACON_SOFT_SCROLLBACK_SIZE=64
+CONFIG_VIDEO_SELECT=y
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+# CONFIG_LOGO is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+# CONFIG_HID_SUPPORT is not set
+# CONFIG_USB_SUPPORT is not set
+# CONFIG_MMC is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_INFINIBAND is not set
+# CONFIG_EDAC is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# SPI RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+
+#
+# DMA Engine support
+#
+CONFIG_DMA_ENGINE=y
+
+#
+# DMA Clients
+#
+CONFIG_NET_DMA=y
+
+#
+# DMA Devices
+#
+# CONFIG_INTEL_IOATDMA is not set
+# CONFIG_VIRTUALIZATION is not set
+
+#
+# Userspace I/O
+#
+# CONFIG_UIO is not set
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_XATTR=y
+CONFIG_EXT3_FS_POSIX_ACL=y
+CONFIG_EXT3_FS_SECURITY=y
+# CONFIG_EXT4DEV_FS is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+CONFIG_FS_POSIX_ACL=y
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_MINIX_FS is not set
+CONFIG_ROMFS_FS=m
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+CONFIG_AUTOFS4_FS=y
+CONFIG_FUSE_FS=y
+CONFIG_GENERIC_ACL=y
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+# CONFIG_NFS_FS is not set
+# CONFIG_NFSD is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+
+#
+# Distributed Lock Manager
+#
+# CONFIG_DLM is not set
+# CONFIG_INSTRUMENTATION is not set
+
+#
+# Kernel hacking
+#
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+# CONFIG_PRINTK_TIME is not set
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_UNUSED_SYMBOLS=y
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+CONFIG_EARLY_PRINTK=y
+CONFIG_X86_FIND_SMP_CONFIG=y
+CONFIG_X86_MPPARSE=y
+CONFIG_DOUBLEFAULT=y
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+CONFIG_CRYPTO_NULL=y
+CONFIG_CRYPTO_MD4=y
+CONFIG_CRYPTO_MD5=y
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_SHA256=y
+CONFIG_CRYPTO_SHA512=y
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+CONFIG_CRYPTO_ECB=y
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+CONFIG_CRYPTO_BLOWFISH=y
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_TWOFISH_586 is not set
+# CONFIG_CRYPTO_SERPENT is not set
+CONFIG_CRYPTO_AES=y
+CONFIG_CRYPTO_AES_586=y
+CONFIG_CRYPTO_CAST5=y
+CONFIG_CRYPTO_CAST6=y
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_DEFLATE=y
+CONFIG_CRYPTO_MICHAEL_MIC=y
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_CAMELLIA is not set
+CONFIG_CRYPTO_TEST=m
+# CONFIG_CRYPTO_HW is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+CONFIG_LIBCRC32C=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_PENDING_IRQ=y
+CONFIG_X86_SMP=y
+CONFIG_X86_HT=y
+CONFIG_X86_BIOS_REBOOT=y
+CONFIG_X86_TRAMPOLINE=y
+CONFIG_KTIME_SCALAR=y
-- 
1.5.2.1


From 4fea885c0c40c83d5734e17a27207ebd5ba1fea9 Mon Sep 17 00:00:00 2001
From: Matt Thomas <baddack@gmail.com>
Date: Thu, 4 Nov 2010 15:54:50 -0700
Subject: [PATCH] Added names and to test is mine is working

---
 Proj2/Makefile           |   33 ---
 Proj2/cpu.c              |  613 ----------------------------------------------
 Proj2/cpu.o              |  Bin 13208 -> 0 bytes
 Proj2/cpuinit.c          |  336 -------------------------
 Proj2/cpuinit.o          |  Bin 6992 -> 0 bytes
 Proj2/list.h             |  244 ------------------
 Proj2/macros.h           |   13 -
 Proj2/privatestructs.h   |   35 ---
 Proj2/profile1           |   44 ----
 Proj2/schedule.c         |  224 -----------------
 Proj2/schedule.c~        |  181 --------------
 Proj2/schedule.h         |   90 -------
 Proj2/schedule.o         |  Bin 4552 -> 0 bytes
 Proj2/schedule.old       |  217 ----------------
 Proj2/vmsched            |  Bin 20452 -> 0 bytes
 linux-2.6.34.7/mm/slob.c |    2 +
 16 files changed, 2 insertions(+), 2030 deletions(-)
 delete mode 100644 Proj2/Makefile
 delete mode 100644 Proj2/cpu.c
 delete mode 100644 Proj2/cpu.o
 delete mode 100644 Proj2/cpuinit.c
 delete mode 100644 Proj2/cpuinit.o
 delete mode 100644 Proj2/list.h
 delete mode 100644 Proj2/macros.h
 delete mode 100644 Proj2/privatestructs.h
 delete mode 100644 Proj2/profile1
 delete mode 100644 Proj2/schedule.c
 delete mode 100644 Proj2/schedule.c~
 delete mode 100644 Proj2/schedule.h
 delete mode 100644 Proj2/schedule.o
 delete mode 100644 Proj2/schedule.old
 delete mode 100755 Proj2/vmsched

diff --git a/Proj2/Makefile b/Proj2/Makefile
deleted file mode 100644
index a619f9c..0000000
--- a/Proj2/Makefile
+++ /dev/null
@@ -1,33 +0,0 @@
-PUBLICH = macros.h list.h
-PRIVATEH = privatestructs.h
-SCHEDULE = schedule.c schedule.h
-
-.PHONY: default
-default: clear app
-
-.PHONY: clear
-clear:
-	clear; clear
-	
-.PHONY: clean
-clean:
-	rm -f *.o
-	rm -f *.gch
-	rm -f vmsched
-	rm -f *.a
-
-.PHONY: lib
-lib: cpu.o cpuinit.o
-	ar rcs libvm.a cpu.o cpuinit.o
-
-app: cpu.o cpuinit.o  schedule.o
-	gcc -o vmsched cpuinit.o cpu.o schedule.o
-
-cpu.o: cpu.c $(SCHEDULE) $(PUBLICH) $(PRIVATEH)
-	gcc -c cpu.c
-
-cpuinit.o: cpuinit.c $(SCHEDULE) $(PUBLICH) $(PRIVATEH)
-	gcc -c cpuinit.c
-
-schedule.o: $(SCHEDULE) $(PUBLICH)
-	gcc -c schedule.c
diff --git a/Proj2/cpu.c b/Proj2/cpu.c
deleted file mode 100644
index 6a463ae..0000000
--- a/Proj2/cpu.c
+++ /dev/null
@@ -1,613 +0,0 @@
-/* cpu.c
- * Main source for linux scheduler virtual machine.
- * Emulates a simple CPU running processes with a generic interrupt
- * for "IO."
- *
- * Requires a properly written schedule.c and schedule.h files 
- * with stubs filled out.
- */
-
-#include "privatestructs.h"
-#include "schedule.h"
-#include <unistd.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <stddef.h>
-#include "list.h" 
-#include "macros.h"
- 
- /* Static methods */
-static void __init_sched();
-static int taskEnd();
-static void spawnChildren();
-static int cycle();
-static int interrupt();
-static void runcpu();
-static void killtask(struct task_struct **p);
-static void shutdowncpu();
-static void badshutdowncpu();
-static void cleanuptask(struct thread_info *p);
-static void forktask(struct thread_info *thread, struct task_struct *parent);
-
-/* External Prototypes */
-struct task_struct *createTask();
-struct thread_info *createInfo(const char *name);
-int readProfile(char *filename);
-
-/* Macros
- * CLOCK_HZ - Sets the clock speed for the VM
- * The other macros are bookkeeping
- * macros for debugging output, and should
- * be self-exlainitory.
- */ 
-#define CLOCK_HZ 500000
-#define HZ_TO_MS (1000 / HZ)
-#define MS_TO_TICKS(ms) (CLOCK_HZ / 1000 * (ms)) 
-#define TICKS_TO_MS(tick) ((long long)((tick) / (long double)CLOCK_HZ * (1000)))
-
-#define LEVEL1(p, q) OUTPUT("", p, q)
-#define LEVEL2(p, q) OUTPUT("\t", p, q)
-#define LEVEL3(p, q) OUTPUT("\t\t", p, q)
-#define OUTPUT(o, p, q) (printf("%s%s/%d/%lldms - %s\n", (o), (p)->thread_info->processName, (p)->time_slice, TICKS_TO_MS(clocktick), (q)))
-#define ALERT(p) (printf("###-%s-###\n", (p)))
- 
-/* Globals 
- * jiffies - A jiffy represents the smallest unit of time that can occur
- *			 between schedule ticks
- * clocktick - The number of cycles the clock has run
- * timer - A "hardware" timer that fires for schedule ticks
- * processID - Next Process ID value
- * rq - A poiner to the runqueue
- * idle - Pointer to the idle task
- * init - Pointer to the init task
- * current - A pointer to the current process in the CPU
- */
-long long jiffies = 0;
-long long clocktick = 0;
-long long timer = 0;
-unsigned int processID = 0;
-extern struct runqueue *rq;
-struct task_struct *idle = NULL;
-struct task_struct *init = NULL;
-extern struct task_struct *current;
-
-/* Control Data
- * cycletime - The delay between cycles in the VM
- * ranSeed - A random seed for the VM
- * intTimer - The general "IO" interrupt, runs from a timer that is
- *			  is randomly set when a process goes to sleep
- * intWaitTimer - A process timer to dictate when an interactive process
- *				  will go and wait on IO
- * endtime - The time in ms when the VM will shutdown (approximately)
- */
-long cycletime = 10;
-int ranSeed = 42;
-long long intTimer = -1;
-long long intWaitTimer = -1;
-long endtime = 1;
- 
-/*-------------- INTERRUPT DATA ---------------*/
-/* This section has data specific to our
- * machines "interrupts."
- */
-/* Return Values */
-#define RESCHEDULE		1
-
-/* This is an IO wait queue */
-struct waitlist
-{
-	struct task_struct *task;
-	struct list_head list;
-};
- 
- /* Wait Queues
-  * This is the wait queue for our "IO"
-  */
-struct list_head intwaitlist;
-
-/*---------------APPLICATION LOGIC------------------*/
-
-/* main
- * Takes a profile to load and run
- */ 
-int main(int argc, char *argv[])
-{
-	if(argc < 2)
-	{
-		printf("Virtual Scheduler\nUsage: vsch [filename]\n");
-		return(1);
-	}
-
-	/* Initialize CPU and scheduler */
-	__init_sched();
-
-	/* Read in the profile */
-	if(!readProfile(argv[1]))
-		goto ERROR;
-		
-	/* Set the random seed we read in */
-	srand(ranSeed);
-	
-	/* Schedule the idle task to "prep" the scheduler */
-	ALERT("Starting CPU");
-	schedule();
-	/* Set first schedule tick timer */
-	timer = MS_TO_TICKS(HZ_TO_MS);
-	/* Start the CPU */
-	runcpu();
-	
-	/* Clean up from the CPU */
-	ALERT("Shutting Down CPU");
-	shutdowncpu();
-	
-	return(0);
-	
-ERROR:
-	/* Cleanup from an error */
-	badshutdowncpu();
-	shutdowncpu();
-	return(1);
-}
-
-/* ---------------------- VM FUNCTIONS -------------------*/
-/* runcpu
- * This is the primary application loop that simulates
- * our "CPU". This code also controls the checking
- * of interrupts.
- */
-static void runcpu()
-{
-	long long lastMS = 0;
-	
-	do
-	{
-		/* Run a single cycle of our application */
-		if(cycle())
-			goto END_CYCLE;
-	INTERRUPT:
-		/* Check for interrupts
-		 * This routine checks for fired
-		 * IO routines or timer ticks
-		 */
-		switch(interrupt())
-		{
-			/* Current task signaled for 
-			 * reschedule
-			 */
-			case RESCHEDULE:
-				clocktick++;
-				schedule();
-				goto END_CYCLE;
-			break;
-		}
-		
-		/* We've completed a clock cycle,
-		 * add a tick.
-		 */
-		clocktick++;
-	END_CYCLE:
-	
-		/* Check for ending conditions for our simulation */
-		if(!init->thread_info->kill && TICKS_TO_MS(clocktick) >= endtime)
-		{
-			ALERT("Sending Kill Message");
-			//isEnding = 1;
-			init->thread_info->kill = 1;
-		}
-		
-		/* Flush output and sleep */
-		fflush(stdout);
-		
-		if(TICKS_TO_MS(clocktick) > lastMS)
-		{
-			lastMS = TICKS_TO_MS(clocktick);
-			
-			if(cycletime > 0)
-				usleep(cycletime);
-		}
-
-	}while(rq->nr_running);
-}
-
-/* cycle
- * Controls process logic, spawning and sleeping,
- * as well as new process creation and process
- * death.
- */
-static int cycle()
-{
-	struct waitlist *tempwaitlist;
-	
-	/* Check to see if the task is ending */
-	if(taskEnd())
-		return(0);
-
-	/* Run logic based on task type */
-	switch(current->thread_info->thread_type)
-	{
-		case INIT:
-		break;
-		
-		/* Interactive tasks need to check to see
-		 * if they are going to wait on IO
-		 */
-		case INTERACTIVE:
-			/* Tick the timer for sleeping */
-			if(intWaitTimer > 0)
-				intWaitTimer--;
-				
-			/* When timer expires, sleep! */
-			if(intWaitTimer == 0)
-			{
-				intWaitTimer--;
-				LEVEL2(current, "Going to Sleep");
-				
-				/* Add task to wait queue */
-				tempwaitlist = (struct waitlist*)malloc(sizeof(struct waitlist));
-				INIT_LIST_HEAD(&tempwaitlist->list);
-				tempwaitlist->task = current;
-				list_add_tail(&tempwaitlist->list, &intwaitlist);
-				
-				/* Deactivate the task and remove it from the 
-				 * scheduler.
-				 */
-				deactivate_task(current);
-				
-				
-				/* We need to be rescheduled! */
-				current->need_reschedule = 1;
-			}
-		break;
-		
-		case NONINTERACTIVE:
-		break;
-	}
-	
-	/* If no other task has slept on IO, 
-	 * set a random time for the next "IO"
-	 * event.
-	 */
-	if(intTimer < 0)
-		intTimer = MS_TO_TICKS(rand() % 1000 + 50);
-	
-	/* Create any children */
-	spawnChildren();
-	
-	return(0);
-}
-
-/* interrupt
- * Checks our computers interrupts
- */
-static int interrupt()
-{	
-		struct list_head *listcur, *listnext;
-		struct waitlist *tempwaitlist;
-		
-	/*----------SCHEDULE TICK TIMER-------------*/
-		/* Decrement the timer */
-		if(timer > 0)
-			timer--;
-		
-		/* Timer Tick! Run the scheduler */
-		if(timer <= 0)
-		{
-			jiffies++;
-			timer = MS_TO_TICKS(HZ_TO_MS);
-			if(current->array != NULL)
-				scheduler_tick(current);
-		}
-
-	/*-------IO EVENT TIMER----------*/
-		/* Decrement the timer */
-		if(intTimer > 0)
-			intTimer--;
-		
-		/* Timer tick! */
-		if(intTimer == 0)
-		{
-			intTimer--;
-			listcur = intwaitlist.next;
-			
-			ALERT("An Interrupt has fired!");
-			
-			/* Check the IO waitlist to see if 
-			 * there are processes sleeping.
-			 */
-			while(listcur != &intwaitlist)
-			{
-				tempwaitlist = list_entry(listcur, struct waitlist, list);
-				LEVEL2(tempwaitlist->task, "Waking Up from Sleep");
-				activate_task(tempwaitlist->task);
-				listnext = listcur->next;
-				list_del(listcur);
-				free(tempwaitlist);
-				listcur = listnext;
-			}
-			
-			/* Notify that we need to reschedule! */
-			current->need_reschedule = 1;
-		}
-		
-		/* If a task needs rescheduling, alert! */
-		if(current->need_reschedule)
-			return(RESCHEDULE);
-		
-	return(0);
-}
-
-/*------------------ SYSTEM CALLS --------------------*/
-/* context_switch
- * This performs a "context switch" for the
- * scheduler.
- */
-void context_switch(struct task_struct *next)
-{
-	LEVEL1(next, "Switching Process In");
-	
-	if(TICKS_TO_MS(clocktick) == 8790)
-		printf("BREAK\n");
-	
-	/* If this is an interactive task,
-	 * set random chance for sleep.
-	 */
-	if(next->thread_info->thread_type == INTERACTIVE)
-		intWaitTimer = MS_TO_TICKS(rand() % (next->time_slice * HZ / 1000 + 100) + 5);
-	
-	/* Set new task as current */
-	current = next;
-}
-
-/* sched_clock
- * Returns the current time (approx)
- * to the scheduler based on
- * jiffies.
- */
-unsigned long long sched_clock()
-{
-	return(JIFFIES_TO_NS(jiffies));
-}
-
-/*-------------------Local Methods-------------------*/
-
-/* __init_sched
- * A pre-initialization function. Sets up
- * Initial tasks and runqueue for scheduler
- * before calling user's function to 
- * setup custom queues.
- */
-static void __init_sched()
-{
-	struct task_struct *task;
-
-	/* Create Init Task */
-	task = createTask();
-	task->thread_info = createInfo("Init");
-	task->thread_info->thread_type = INIT;
-	task->thread_info->kill_time = -1;
-
-	INIT_LIST_HEAD(&task->run_list);
-	INIT_LIST_HEAD(&task->thread_info->list);
-	//task->time_slice = task_timeslice(task);
-
-	/* Assign to global pointer for Config */
-	init = task;
-
-	/* Initialize Runqueue */
-	rq = (struct runqueue*)malloc(sizeof(struct runqueue));
-	rq->curr = NULL;
-	rq->nr_running = 0;
-	rq->nr_switches = 0;
-	rq->best_expired_prio = MAX_PRIO;
-	rq->expired_timestamp = 0;
-	
-	/* Initialize Scheduler */
-	initschedule(rq, init);
-	
-	/* Create Idle Task */
-	idle = createTask();
-	idle->thread_info = createInfo("IDLE");
-	processID--;
-	current = idle;
-	
-	/* Prepare List heads */
-	INIT_LIST_HEAD(&intwaitlist);
-}
-
-/* forktask
- * Creates data structures for a new process being spawned
- * from a parent. Finally, it submits the task to the
- * scheduler.
- */
-static void forktask(struct thread_info *thread, struct task_struct *parent)
-{
-	struct task_struct *task;
-	char str[1024];
-	
-	task = createTask();
-	task->thread_info = thread;
-	task->thread_info->id = processID++;
-	task->thread_info->children = 0;
-	task->thread_info->kill = 0;
-	
-	/* Assigne Thread Name */
-	if(parent->thread_info->parent != NULL)
-		sprintf(str, "%s:(%s:%d)", parent->thread_info->processName, task->thread_info->processName, task->thread_info->id);
-	else
-		sprintf(str, "(%s:%d)", task->thread_info->processName, task->thread_info->id);
-
-	free(task->thread_info->processName);
-	task->thread_info->processName = (char*)malloc(strlen(str) + 1);
-	memcpy(task->thread_info->processName, str, strlen(str) + 1);
-
-	/* If the parent is not INIT, display parent info */
-	if(thread->parent != NULL)
-		thread->parent->children++;
-	
-	/* Set NICE value */
-	task->static_prio = NICE_TO_PRIO(task->thread_info->niceValue);
-	
-	/* Alert Creation */
-	printf("###-Process: %s has been created-###\n", thread->processName);
-	/* Fork process in Scheduler */
-	sched_fork(task);
-	/* Wake up the task */
-	wake_up_new_task(task);
-	/* Signal need for schedule call */
-	current->need_reschedule = 1;
-}
-
-/* taskEnd
- * Checks for an exit signal for the current 
- * running task.
- */
-static int taskEnd()
-{
-	/* Check to see if the time for this process to end
-	 * has passed.
-	 */
-	 if(current->thread_info->kill ||
-	    (current->thread_info->parent != NULL && current->thread_info->parent->kill) ||
-	    (current->thread_info->kill_time >= 0 && TICKS_TO_MS(clocktick) >= current->thread_info->kill_time)
-	   )
-	{
-		if(!current->thread_info->kill)
-			current->thread_info->kill = 1;
-		
-		if(current->thread_info->children == 0)
-		{
-			deactivate_task(current);
-			killtask(&current);
-			return(1);
-		}
-	}
-	
-	return(0);
-}
-
-/* spawnChildren
- * Spanws children for processes
- */
-static void spawnChildren()
-{
-	struct list_head *child, *next;;
-	struct thread_info *temp;
-
-	/* Make sure the current process can spawn */
-	if(current->thread_info->spawns)
-	{
-		/* Run through the list of children to be spawned */
-		child = &current->thread_info->list;
-		child = child->next;
-		while(child != &current->thread_info->list)
-		{
-			/* If it is time to spawn a child,
-			 * spawn that child.
-			 */
-			temp = list_entry(child, struct thread_info, clist);
-			if(MS_TO_TICKS(temp->spawn_time) <= clocktick) 
-			{
-				forktask(temp, current);
-				next = child;
-				child = child->next;
-				list_del(next);
-			}
-			else	
-				child = child->next;
-		}
-	}
-}
-
-/* killtask
- * Kills the current running task and 
- * removes it from the scheduler.
- */
-static void killtask(struct task_struct **p)
-{
-	struct task_struct *j = *p;
-
-	printf("###-Process: %s is going down-###\n", j->thread_info->processName); 
-
-	/* If task has a parent, decrement the parent's
-	 * count of running children.
-	 */
-	if(j->thread_info->parent != NULL)
-		j->thread_info->parent->children--;
-	
-	/* Free data structures */
-	free(j->thread_info->processName);
-	free(j->thread_info);
-	free(j);
-	
-	/* Set the idle task in place
-	 * of the current one so the
-	 * scheduler works correctly.
-	 */
-	*p = idle;
-	j = *p;
-	
-	/* If there are still tasks to be run, run them. */
-	if(rq->nr_running != 0)
-		j->need_reschedule = 1;
-}
-
-/* shutdowncpu
- * Releases data structures during a normal
- * shutdown.
- */
-static void shutdowncpu()
-{
-	free(idle->thread_info->processName);
-	free(idle->thread_info);
-	free(idle);
-	
-	/* Shuts down the scheduler */
-	killschedule();
-	/* Free the runqueue */
-	free(rq);
-}
-
-/* badshutdowncpu
- * Frees data structures left in memory when
- * an error occurs.
- */
-static void badshutdowncpu()
-{
-	cleanuptask(init->thread_info);
-	
-	if(init->thread_info->processName != NULL)
-		free(init->thread_info->processName);
-	free(init->thread_info);
-	free(init);
-}
-
-/* cleanuptask
- * A recursive helper function
- * for badshutdowncpu which
- * recursively frees child tasks
- */
-static void cleanuptask(struct thread_info *p)
-{
-	struct list_head *child, *next;
-	struct thread_info *temp;
-
-	child = &p->list;
-	child = child->next;
-	while(child != NULL && child != &p->list)
-	{
-		temp = list_entry(child, struct thread_info, clist);
-		next = child;
-		child = child->next;
-		list_del(next);
-		
-		/* Clean up task children */
-		cleanuptask(temp);
-		
-		/* Clean up this task */
-		if(temp->processName != NULL)
-			free(temp->processName);
-		free(temp);
-	}
-}
-
diff --git a/Proj2/cpu.o b/Proj2/cpu.o
deleted file mode 100644
index 4e3c4e50a53cf52fdf17c1a2d232d1dcda5ffdfa..0000000000000000000000000000000000000000
GIT binary patch
literal 0
Hc$@<O00001

literal 13208
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

diff --git a/Proj2/cpuinit.c b/Proj2/cpuinit.c
deleted file mode 100644
index 719a2be..0000000
--- a/Proj2/cpuinit.c
+++ /dev/null
@@ -1,336 +0,0 @@
-/* cpuinit.c
- * Contains a few *large* helper functions
- * for initializing the virtual machine.
- * The main guts here is the parser,
- * which is fairly large and parses
- * the CPU profiles.
- */
- 
-#include <stdio.h>
-#include <stdlib.h>
-#include "schedule.h"
-#include "privatestructs.h"
-#include <string.h>
-
-/* Parse Data */
-#define CSIZE 12
-#define TSIZE 2
-
-/* The various parse options */
-char *coptions[CSIZE] = 	{
-"CYCLE_TIME",
-"NEWPROCESS",
-"ENDPROCESS",
-"SPAWNTIME", 
-"NAME",
-"TYPE",
-"SEED", 
-"ENDTIME",
-"KILLTIME",
-"NICE",
-"SPAWN",
-"ENDSPAWN"
-};
-
-/* Type Options */
-char *ttype[TSIZE] = {
-"INTERACTIVE",
-"NONINTERACTIVE"
-};
-
-int tint[TSIZE] = {
-INTERACTIVE,
-NONINTERACTIVE
-};
-
-/* Static prototypes */
-static int readint(FILE *fp);
-static void readstring(FILE *fp, char **str);
-
-/* External References */
-extern struct task_struct *idle;
-extern struct task_struct *init;
-extern int processID;
-extern int cycletime;
-extern int ranSeed;
-extern long endtime;
-
-/* createTask 
- * Helper method that creates and zeros
- * a task_struct.
- */
-struct task_struct *createTask()
-{
-	struct task_struct *task;
-	
-	task = (struct task_struct*)malloc(sizeof(struct task_struct));
-	task->thread_info = (struct thread_info*)malloc(sizeof(struct thread_info));
-	task->static_prio = NICE_TO_PRIO(0);
-	task->prio = 0;
-	task->sleep_avg = 0;
-	task->time_slice = 0;
-	task->first_time_slice = 0;
-	task->need_reschedule = 0;
-	task->last_ran = 0;
-	task->timestamp = 0;
-	
-	return(task);
-}
-
-/* createInfo
- * Helper method that creates and zeros
- * a thread_info struct.
- */
-struct thread_info *createInfo(const char *name)
-{
-	struct thread_info *thread_info;
-	char pname[1024];
-	
-	thread_info = (struct thread_info*)malloc(sizeof(struct thread_info));
-	thread_info->id = processID++;
-	thread_info->parent = NULL;
-	thread_info->spawns = 0;
-	thread_info->niceValue = 0;
-	thread_info->kill = 0;
-	thread_info->thread_type = -1;
-	thread_info->children = 0;
-	thread_info->type_struct = NULL;
-	sprintf(pname, "%d", thread_info->id);
-	thread_info->processName = (char *)malloc(strlen(name) + strlen(pname) + 4);
-	sprintf(thread_info->processName, "(%s:%s)", name, pname);
-	
-	return(thread_info);
-}
-
-/* readProfile
- * Main body of parser.
- */
-int readProfile(char *filename)
-{
-	int i, j, offset;
-	char copt[50];
-	char *temp;
-	FILE *fp;
-	int children = 0;
-	struct thread_info *newtask = NULL;
-	struct thread_info *old;
-	struct thread_info *top = init->thread_info;
-	top->spawns = 1;
-	
-	if((fp = fopen(filename, "r")) == NULL)
-	{
-		printf("ERROR: profile %s not found\n", filename);
-		return(0);
-	}
-
-	while(!feof(fp))
-	{
-		/* Eat Whitespace */
-		WHITESPACE:
-			if(!fread(copt, 1, 1, fp))
-				continue;
-			if(isspace(*copt))
-				goto WHITESPACE;
-
-		/* Ignore whitespace */
-		if(*copt == ';')
-		{
-			while(*copt != '\n')
-				if(!fread(copt, 1, 1, fp))
-					continue;
-			if(*copt != '#')
-				continue;
-		}
-
-		if(*copt != '#')
-		{
-			printf("Missing '#' at beginning of command\n");
-			return(0);
-		}
-
-		/* Read option */
-		i = 0;
-		while(!feof(fp))
-		{
-			if(i >= 48)
-				return(0);
-
-			if(!fread((copt + i), 1, 1, fp))
-				goto WHITESPACE;
-			if(isspace(*(copt + i)))
-				break;
-			i++;
-		};
-
-		*(copt + i) = '\0';
-
-		/* Parse Option */
-		offset = -1;
-		for(i = 0; i < CSIZE; i++)
-		{
-			/*printf("Comparing %s to %s\n", copt, coptions[i]);*/
-
-			if(strcmp(copt, coptions[i]) == 0)
-			{
-				offset = i;
-				break;
-			}
-			
-		}
-
-		if(offset == -1)
-		{
-			printf("Command %s is unknown\n", copt);
-			return(0);
-		}
-
-		/* Eat Whitespace */
-		WHITESPACE_VAL:
-			if(!fread(copt, 1, 1, fp))
-				continue;
-			if(isspace(*copt))
-				goto WHITESPACE_VAL;
-
-		fseek(fp, -1, SEEK_CUR);
-
-		/* Parse Value
-		 * Switched off of parse array
-		 */
-		switch(i)
-		{
-			/* Read Int */
-			case 0: /* Cycle Delay */
-				cycletime = readint(fp);
-			break;
-			
-			case 1: /* New Process */
-				newtask = (struct thread_info*)malloc(sizeof(struct thread_info));
-				newtask->kill_time = -1;
-				newtask->niceValue = 0;
-				newtask->parent = top;
-				INIT_LIST_HEAD(&newtask->list);
-				list_add_tail(&newtask->clist, &top->list);
-			break;
-			
-			case 2: /* End Process */
-				newtask = NULL;
-			break;
-			
-			case 3: /* Spawn Time */
-				newtask->spawn_time = readint(fp);
-			break;
-				
-			case 4: /* Name */
-				readstring(fp, &newtask->processName);
-			break;
-			
-			case 5: /* Type */
-				readstring(fp, &temp);
-				offset = 0;
-				for(j = 0; j < TSIZE; j++)
-				{
-					if(strcmp(ttype[j], temp) == 0)
-					{
-						newtask->thread_type = tint[j];
-						offset = 1;
-					}
-				}
-				
-				if(!offset)
-					printf("Bad type!\n");
-			break;
-			
-			case 6: /* randomd seed */
-				ranSeed = readint(fp);
-			break;
-			
-			case 7: /* endtime */
-				endtime = readint(fp);
-			break;
-			
-			case 8: /* Kill time */
-				newtask->kill_time = readint(fp);
-			break;
-			
-			case 9: /* Nice Value */
-				newtask->niceValue = readint(fp);
-				if(newtask->niceValue < -19 || newtask->niceValue > 20)
-					newtask->niceValue = 0;
-			break;
-			
-			case 10: /* SPAWN */
-				children++;
-				top = newtask;
-				top->spawns = 1;
-			break;
-			
-			case 11: /* ENDSPAWN */
-				children--;
-				old = top;
-				top = top->parent;
-				newtask = old;
-			break;
-			
-			default:
-				return(0);
-			break;
-		}
-	}
-	
-
-	fclose(fp);
-
-	if(children)
-		return(0);
-		
-	return(1);
-}
-
-/* readint
- * Helper function. Reads an integer from
- * the file.
- */
-static int readint(FILE *fp)
-{
-	int val;
-
-	fscanf(fp, "%d", &val);
-	
-	return(val);
-}
-
-/* readstring
- * Helper function. Reads a 
- * string from the file.
- */
-static void readstring(FILE *fp, char **str)
-{
-	int i = 0, j = 0;
-	char c;	
-
-	*str = NULL;
-
-	while(!feof(fp))
-	{
-		if(!fread(&c, 1, 1, fp))
-			continue;
-		if(isspace(c))
-			break;
-
-		i++;
-	}
-	
-	if(i == 0)
-		return;
-
-	*str = (char*)malloc(sizeof(char) * (i + 1));
-
-	fseek(fp, -i - 1, SEEK_CUR);
-	
-	for(j = 0; j < i; j++)
-		fread((*str + j), 1, 1, fp);
-	
-	*(*str + i) = '\0';
-
-	return;
-}
diff --git a/Proj2/cpuinit.o b/Proj2/cpuinit.o
deleted file mode 100644
index 28110030bc7f86af84ee0a788db615e9dcc0fd1e..0000000000000000000000000000000000000000
GIT binary patch
literal 0
Hc$@<O00001

literal 6992
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
PH#u&8S1)kf{C@s7(6@5-

diff --git a/Proj2/list.h b/Proj2/list.h
deleted file mode 100644
index 3a76885..0000000
--- a/Proj2/list.h
+++ /dev/null
@@ -1,244 +0,0 @@
-#ifndef __LIST_H
-#define __LIST_H
-
-/* This file is from Linux Kernel (include/linux/list.h) 
- * and modified by simply removing hardware prefetching of list items. 
- * Here by copyright, credits attributed to wherever they belong.
- * Kulesh Shanmugasundaram (kulesh [squiggly] isis.poly.edu)
- */
-
-/*
- * Simple doubly linked list implementation.
- *
- * Some of the internal functions ("__xxx") are useful when
- * manipulating whole lists rather than single entries, as
- * sometimes we already know the next/prev entries and we can
- * generate better code by using them directly rather than
- * using the generic single-entry routines.
- */
-
-struct list_head {
-	struct list_head *next, *prev;
-};
-
-#define LIST_HEAD_INIT(name) { &(name), &(name) }
-
-#define LIST_HEAD(name) \
-	struct list_head name = LIST_HEAD_INIT(name)
-
-#define INIT_LIST_HEAD(ptr) do { \
-	(ptr)->next = (ptr); (ptr)->prev = (ptr); \
-} while (0)
-
-/*
- * Insert a new entry between two known consecutive entries. 
- *
- * This is only for internal list manipulation where we know
- * the prev/next entries already!
- */
-static inline void __list_add(struct list_head *new,
-			      struct list_head *prev,
-			      struct list_head *next)
-{
-	next->prev = new;
-	new->next = next;
-	new->prev = prev;
-	prev->next = new;
-}
-
-/**
- * list_add - add a new entry
- * @new: new entry to be added
- * @head: list head to add it after
- *
- * Insert a new entry after the specified head.
- * This is good for implementing stacks.
- */
-static inline void list_add(struct list_head *new, struct list_head *head)
-{
-	__list_add(new, head, head->next);
-}
-
-/**
- * list_add_tail - add a new entry
- * @new: new entry to be added
- * @head: list head to add it before
- *
- * Insert a new entry before the specified head.
- * This is useful for implementing queues.
- */
-static inline void list_add_tail(struct list_head *new, struct list_head *head)
-{
-	__list_add(new, head->prev, head);
-}
-
-/*
- * Delete a list entry by making the prev/next entries
- * point to each other.
- *
- * This is only for internal list manipulation where we know
- * the prev/next entries already!
- */
-static inline void __list_del(struct list_head *prev, struct list_head *next)
-{
-	next->prev = prev;
-	prev->next = next;
-}
-
-/**
- * list_del - deletes entry from list.
- * @entry: the element to delete from the list.
- * Note: list_empty on entry does not return true after this, the entry is in an undefined state.
- */
-static inline void list_del(struct list_head *entry)
-{
-	__list_del(entry->prev, entry->next);
-	entry->next = (void *) 0;
-	entry->prev = (void *) 0;
-}
-
-/**
- * list_del_init - deletes entry from list and reinitialize it.
- * @entry: the element to delete from the list.
- */
-static inline void list_del_init(struct list_head *entry)
-{
-	__list_del(entry->prev, entry->next);
-	INIT_LIST_HEAD(entry); 
-}
-
-/**
- * list_move - delete from one list and add as another's head
- * @list: the entry to move
- * @head: the head that will precede our entry
- */
-static inline void list_move(struct list_head *list, struct list_head *head)
-{
-        __list_del(list->prev, list->next);
-        list_add(list, head);
-}
-
-/**
- * list_move_tail - delete from one list and add as another's tail
- * @list: the entry to move
- * @head: the head that will follow our entry
- */
-static inline void list_move_tail(struct list_head *list,
-				  struct list_head *head)
-{
-        __list_del(list->prev, list->next);
-        list_add_tail(list, head);
-}
-
-/**
- * list_empty - tests whether a list is empty
- * @head: the list to test.
- */
-static inline int list_empty(struct list_head *head)
-{
-	return head->next == head;
-}
-
-static inline void __list_splice(struct list_head *list,
-				 struct list_head *head)
-{
-	struct list_head *first = list->next;
-	struct list_head *last = list->prev;
-	struct list_head *at = head->next;
-
-	first->prev = head;
-	head->next = first;
-
-	last->next = at;
-	at->prev = last;
-}
-
-/**
- * list_splice - join two lists
- * @list: the new list to add.
- * @head: the place to add it in the first list.
- */
-static inline void list_splice(struct list_head *list, struct list_head *head)
-{
-	if (!list_empty(list))
-		__list_splice(list, head);
-}
-
-/**
- * list_splice_init - join two lists and reinitialise the emptied list.
- * @list: the new list to add.
- * @head: the place to add it in the first list.
- *
- * The list at @list is reinitialised
- */
-static inline void list_splice_init(struct list_head *list,
-				    struct list_head *head)
-{
-	if (!list_empty(list)) {
-		__list_splice(list, head);
-		INIT_LIST_HEAD(list);
-	}
-}
-
-/**
- * list_entry - get the struct for this entry
- * @ptr:	the &struct list_head pointer.
- * @type:	the type of the struct this is embedded in.
- * @member:	the name of the list_struct within the struct.
- */
-#define list_entry(ptr, type, member) \
-	((type *)((char *)(ptr)-(unsigned long)(&((type *)0)->member)))
-
-/**
- * list_for_each	-	iterate over a list
- * @pos:	the &struct list_head to use as a loop counter.
- * @head:	the head for your list.
- */
-#define list_for_each(pos, head) \
-	for (pos = (head)->next; pos != (head); \
-        	pos = pos->next)
-/**
- * list_for_each_prev	-	iterate over a list backwards
- * @pos:	the &struct list_head to use as a loop counter.
- * @head:	the head for your list.
- */
-#define list_for_each_prev(pos, head) \
-	for (pos = (head)->prev; pos != (head); \
-        	pos = pos->prev)
-        	
-/**
- * list_for_each_safe	-	iterate over a list safe against removal of list entry
- * @pos:	the &struct list_head to use as a loop counter.
- * @n:		another &struct list_head to use as temporary storage
- * @head:	the head for your list.
- */
-#define list_for_each_safe(pos, n, head) \
-	for (pos = (head)->next, n = pos->next; pos != (head); \
-		pos = n, n = pos->next)
-
-/**
- * list_for_each_entry	-	iterate over list of given type
- * @pos:	the type * to use as a loop counter.
- * @head:	the head for your list.
- * @member:	the name of the list_struct within the struct.
- */
-#define list_for_each_entry(pos, head, member)				\
-	for (pos = list_entry((head)->next, typeof(*pos), member);	\
-	     &pos->member != (head); 					\
-	     pos = list_entry(pos->member.next, typeof(*pos), member))
-
-/**
- * list_for_each_entry_safe - iterate over list of given type safe against removal of list entry
- * @pos:	the type * to use as a loop counter.
- * @n:		another type * to use as temporary storage
- * @head:	the head for your list.
- * @member:	the name of the list_struct within the struct.
- */
-#define list_for_each_entry_safe(pos, n, head, member)			\
-	for (pos = list_entry((head)->next, typeof(*pos), member),	\
-		n = list_entry(pos->member.next, typeof(*pos), member);	\
-	     &pos->member != (head); 					\
-	     pos = n, n = list_entry(n->member.next, typeof(*n), member))
-
-
-#endif
diff --git a/Proj2/macros.h b/Proj2/macros.h
deleted file mode 100644
index a532fff..0000000
--- a/Proj2/macros.h
+++ /dev/null
@@ -1,13 +0,0 @@
-#ifndef MACROS_H
-#define MACROS_H
-
-#define HZ 100
-
-#define MAX_PRIO 1
-#define NICE_TO_PRIO(p) (0)
-
-#define JIFFIES_TO_NS(TIME) ((TIME) * (1000000000 / HZ))
-#define NS_TO_JIFFIES(TIME) ((TIME) / (1000000000 / HZ))
-
-#endif
-
diff --git a/Proj2/privatestructs.h b/Proj2/privatestructs.h
deleted file mode 100644
index 95ea24b..0000000
--- a/Proj2/privatestructs.h
+++ /dev/null
@@ -1,35 +0,0 @@
-/* privatestruct
- * This file contains data structures that are 
- * exclusively for the VM, and should not be
- * accessible to the scheduler.
- */
-
-#ifndef PRIVATESTRUCTS_H
-#define PRIVATESTRUCTS_H
-
-#include "list.h"
-
-// Task Types
-#define INIT				0
-#define INTERACTIVE			1
-#define NONINTERACTIVE		2
-
-struct thread_info
-{
-	int id;
-	int spawn_time;
-	int kill_time;
-	int niceValue;
-	int spawns;
-	int children;
-	int kill;
-	int thread_type;
-	void *type_struct;
-	char *processName;
-	struct thread_info *parent;
-	struct list_head list;
-	struct list_head clist;
-};
-
-#endif
-
diff --git a/Proj2/profile1 b/Proj2/profile1
deleted file mode 100644
index d1a328a..0000000
--- a/Proj2/profile1
+++ /dev/null
@@ -1,44 +0,0 @@
-#CYCLE_TIME 0
-#SEED 345
-#ENDTIME 10000
-
-#NEWPROCESS
-#TYPE INTERACTIVE
-#NAME Sleeper
-#NICE -10
-#SPAWNTIME 562
-#ENDPROCESS
-
-#NEWPROCESS 
-#TYPE INTERACTIVE
-#NAME Interactive
-#SPAWNTIME 100
-#KILLTIME 400
-#ENDPROCESS
-
-#NEWPROCESS 
-#TYPE INTERACTIVE
-#NAME Interactive
-#SPAWNTIME 500
-#ENDPROCESS
-
-#NEWPROCESS
-#TYPE INTERACTIVE
-#NAME Non-Interactive
-#SPAWNTIME 324
-#NICE 4
-#ENDPROCESS
-
-#NEWPROCESS
-#TYPE NONINTERACTIVE
-#NAME Spawner
-#SPAWNTIME 1
-#NICE 20
-#SPAWN
-	#NEWPROCESS
-	#TYPE INTERACTIVE
-	#NAME Interactive
-	#SPAWNTIME 200
-	#ENDPROCESS
-#ENDSPAWN
-#ENDPROCESS
diff --git a/Proj2/schedule.c b/Proj2/schedule.c
deleted file mode 100644
index 6d98340..0000000
--- a/Proj2/schedule.c
+++ /dev/null
@@ -1,224 +0,0 @@
-/* schedule.c
- * This file contains the primary logic for the 
- * scheduler.
- */
-//CS 411 Project 2
-//Matt Thomas, Sarah Clisby, Matt Martinson, Ian Crawford
-#include "schedule.h"
-#include "macros.h"
-#include <stddef.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-#define NEWTASKSLICE (NS_TO_JIFFIES(100000000))
-
-/* Local Globals
- * rq - This is a pointer to the runqueue that the scheduler uses.
- * current - A pointer to the current running task.
- */
-struct runqueue *rq;
-struct task_struct *current;
-
-/* External Globals
- * jiffies - A discrete unit of time used for scheduling.
- *			 There are HZ jiffies in a second, (HZ is 
- *			 declared in macros.h), and is usually
- *			 1 or 10 milliseconds.
- */
-extern long long jiffies;
-
-
-/*-----------------Initilization/Shutdown Code-------------------*/
-/* This code is not used by the scheduler, but by the virtual machine
- * to setup and destroy the scheduler cleanly.
- */
- 
- /* initscheduler
-  * Sets up and allocates memory for the scheduler, as well
-  * as sets initial values. This function should also
-  * set the initial effective priority for the "seed" task 
-  * and enqueu it in the scheduler.
-  * INPUT:
-  * newrq - A pointer to an allocated rq to assign to your
-  *			local rq.
-  * seedTask - A pointer to a task to seed the scheduler and start
-  * the simulation.
-  */
-
-void initschedule(struct runqueue *newrq, struct task_struct *seedTask)
-{
-    printf( "Begin init.\n" );
-    struct sched_array* actual;
-
-    newrq->nr_running = 0;
-    newrq->nr_switches = 0;
-
-    actual = malloc( 2 *  sizeof( struct sched_array ) );
-    newrq->arrays[ 0 ] = actual[ 0 ];
-
-    newrq->active = &newrq->arrays[ 0 ];
-    INIT_LIST_HEAD( &newrq->arrays[ 0 ].array );
-
-    enqueue_task( seedTask, newrq->active );
-
-    seedTask->need_reschedule = 1;
-
-    seedTask->first_time_slice = NEWTASKSLICE;
-    seedTask->time_slice = NEWTASKSLICE;
-
-    rq = newrq;
-}
-
-/* killschedule
- * This function should free any memory that 
- * was allocated when setting up the runqueu.
- * It SHOULD NOT free the runqueue itself.
- */
-void killschedule()
-{
-    printf( "Begin Kill.\n" );
-    //free( rq->arrays );
-    //free( rq->arrays );
-}
-
-/*-------------Scheduler Code Goes Below------------*/
-/* This is the beginning of the actual scheduling logic */
-
-/* schedule
- * Gets the next task with the shortest runtime(time slice) remaining
- */
-void schedule()
-{
-    //printf( "Calling schedule\n" );
-
-    struct list_head* pos = NULL;
-
-    struct task_struct *task = NULL;
-    struct task_struct *next = NULL;
-    
-    unsigned int rem_time = -1;
-  
-    list_for_each( pos, &rq->active->array )
-        {
-        task = list_entry( pos, struct task_struct, run_list );
-        if( task->need_reschedule )
-	    {
-   	   	if( task->time_slice <= 0 )
-		{
-                    task->first_time_slice = NEWTASKSLICE;
-		    task->time_slice = task->first_time_slice;
-                    task->need_reschedule = 1;
-		}
-		else if( task->time_slice < rem_time )
-		{
- 		    next = task;
-                    rem_time = task->time_slice;
-		}
-	    }
-        }
-    if( next != NULL && next != current )
-	{	
-	    rq->nr_switches++;
-            context_switch( next );
-            rq->curr = next;
-            next->need_reschedule = 0;
-	}
-}
-
-
-/* enqueue_task
- * Enqeueus a task in the passed sched_array
- */
-void enqueue_task(struct task_struct *p, struct sched_array *array)
-{
-    //printf( "Calling enqueue_task\n" );
-    list_add( &p->run_list, &array->array );
-    p->array = array;
-    rq->nr_running++;
-}
-
-/* dequeue_task
- * Removes a task from the passed sched_array
- */
-void dequeue_task(struct task_struct *p, struct sched_array *array)
-{
-    //printf( "Calling dequue_task\n" );
-
-    list_del( &p->run_list );
-    p->array = NULL;   
-    rq->nr_running--;
-}
-
-/* sched_fork
- * Sets up schedule info for a newly forked task
- */
-void sched_fork(struct task_struct *p)
-{	
-    int new_slice = current->first_time_slice / 2;
-    rq->curr->first_time_slice = new_slice;
-    p->first_time_slice = new_slice;
-    p->time_slice = p->first_time_slice;
-}
-
-/* scheduler_tick
- * Updates information and priority
- * for the task that is currently running.
- */
-void scheduler_tick(struct task_struct *p)
-{	
-    p->time_slice--;
-    if( p->time_slice <= 0 )
-    {
-        p->need_reschedule = 1;
-    }
-}
-
-/* wake_up_new_task
- * Prepares information for a task
- * that is waking up for the first time
- * (being created).
- * Also handles preemption, e.g. decides 
- * whether or not the current task should
- * call scheduler to allow for this one to run
- */
-void wake_up_new_task(struct task_struct *p)
-{	
-    __activate_task( p );
-    if( current->time_slice >= p->time_slice )
-    {
-        p->need_reschedule = 1;
-    }
-}
-
-/* __activate_task
- * Activates the task in the scheduler
- * by adding it to the active array.
- */
-void __activate_task(struct task_struct *p)
-{
-    enqueue_task( p, rq->active );
-}
-
-/* activate_task
- * Activates a task that is being woken-up
- * from sleeping.
- */
-void activate_task(struct task_struct *p)
-{	
-    //printf( "Calling activate_task\n" );
-    __activate_task( p );
-    p->need_reschedule = 1;
-}
-
-/* deactivate_task
- * Removes a running task from the scheduler to
- * put it to sleep.
- */
-void deactivate_task(struct task_struct *p)
-{
-    //printf( "Calling deactivate_task\n" );
-    p->need_reschedule = 0;
-    dequeue_task( p , rq->active);
-    //printf( "deactive done\n" );
-}
diff --git a/Proj2/schedule.c~ b/Proj2/schedule.c~
deleted file mode 100644
index 058444e..0000000
--- a/Proj2/schedule.c~
+++ /dev/null
@@ -1,181 +0,0 @@
-/* schedule.c
- * This file contains the primary logic for the 
- * scheduler.
- */
-#include "schedule.h"
-#include "macros.h"
-#include <stddef.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-#define NEWTASKSLICE (NS_TO_JIFFIES(100000000))
-#define NUMPRIOR 140;
-
-/* Local Globals
- * rq - This is a pointer to the runqueue that the scheduler uses.
- * current - A pointer to the current running task.
- */
-struct runqueue *rq;
-struct task_struct *current;
-
-/* External Globals
- * jiffies - A discrete unit of time used for scheduling.
- *			 There are HZ jiffies in a second, (HZ is 
- *			 declared in macros.h), and is usually
- *			 1 or 10 milliseconds.
- */
-extern long long jiffies;
-
-
-/*-----------------Initilization/Shutdown Code-------------------*/
-/* This code is not used by the scheduler, but by the virtual machine
- * to setup and destroy the scheduler cleanly.
- */
- 
- /* initscheduler
-  * Sets up and allocates memory for the scheduler, as well
-  * as sets initial values. This function should also
-  * set the initial effective priority for the "seed" task 
-  * and enqueu it in the scheduler.
-  * INPUT:
-  * newrq - A pointer to an allocated rq to assign to your
-  *			local rq.
-  * seedTask - A pointer to a task to seed the scheduler and start
-  * the simulation.
-  */
-void initschedule(struct runqueue *newrq, struct task_struct *seedTask)
-{
-    printf( "Begin init.\n" );
-    //struct sched_array actual[ 2 ];
-    struct sched_array* actual;
-
-    newrq->nr_running = 1;
-    newrq->nr_switches = 0;
-    newrq->expired_timestamp = 0;
-    newrq->most_recent_timestamp = 0;
-    newrq->curr = seedTask;
-
-    actual = malloc( 2 * sizeof( struct sched_array ) );
-    newrq->arrays[ 0 ] = actual[ 0 ];
-    newrq->arrays[ 1 ] = actual[ 1 ];
-
-    newrq->active = &newrq->arrays[ 0 ];
-    //newrq->expired = &newrq->arrays[ 1 ];
-
-    //INIT_LIST_HEAD( newrq->arrays[ 0 ].array )
-
-    newrq->active->array.next = &seedTask->run_list;
-    newrq->active->array.prev = &seedTask->run_list;
-
-    //seedTask->need_reschedule = 1; 
-
-    newrq->best_expired_prio = 0;
-
-    seedTask->prio = NUMPRIOR;
-    seedTask->static_prio = NUMPRIOR;
-    seedTask->normal_prio = NUMPRIOR;
-
-    rq = newrq;
-
-    printf( "Finish init.\n" );
-}
-
-/* killschedule
- * This function should free any memory that 
- * was allocated when setting up the runqueu.
- * It SHOULD NOT free the runqueue itself.
- */
-void killschedule()
-{
-    printf( "Begin Kill.\n" );
-    free( rq->arrays );
-    printf( "Finished kill.\n" );
-}
-
-/*-------------Scheduler Code Goes Below------------*/
-/* This is the beginning of the actual scheduling logic */
-
-/* schedule
- * Gets the next task with the shortest runtime(time slice) remaining
- */
-void schedule()
-{
-    printf( "Calling schedule\n" );
-    sleep( 1 );
-}
-
-
-/* enqueue_task
- * Enqeueus a task in the passed sched_array
- */
-void enqueue_task(struct task_struct *p, struct sched_array *array)
-{
-    printf( "Calling enqueue_task\n" );
-    list_add( &p->run_list, &array->array );
-}
-
-/* dequeue_task
- * Removes a task from the passed sched_array
- */
-void dequeue_task(struct task_struct *p, struct sched_array *array)
-{
-    printf( "Calling dequue_task\n" );
-    list_del( &p->run_list, &array->array );
-}
-
-/* sched_fork
- * Sets up schedule info for a newly forked task
- */
-void sched_fork(struct task_struct *p)
-{	
-    printf( "Calling sched_fork\n" );
-}
-
-/* scheduler_tick
- * Updates information and priority
- * for the task that is currently running.
- */
-void scheduler_tick(struct task_struct *p)
-{	
-    printf( "Calling scheduler_tick\n" );
-}
-
-/* wake_up_new_task
- * Prepares information for a task
- * that is waking up for the first time
- * (being created).
- * Also handles preemption, e.g. decides 
- * whether or not the current task should
- * call scheduler to allow for this one to run
- */
-void wake_up_new_task(struct task_struct *p)
-{	
-    printf( "Calling wake_up_new_task\n" );
-}
-
-/* __activate_task
- * Activates the task in the scheduler
- * by adding it to the active array.
- */
-void __activate_task(struct task_struct *p)
-{
-}
-
-/* activate_task
- * Activates a task that is being woken-up
- * from sleeping.
- */
-void activate_task(struct task_struct *p)
-{		
-    printf( "Calling activate_task\n" );
-}
-
-/* deactivate_task
- * Removes a running task from the scheduler to
- * put it to sleep.
- */
-void deactivate_task(struct task_struct *p)
-{
-    printf( "Calling deactivate_task\n" );
-}
diff --git a/Proj2/schedule.h b/Proj2/schedule.h
deleted file mode 100644
index 425e4b0..0000000
--- a/Proj2/schedule.h
+++ /dev/null
@@ -1,90 +0,0 @@
-#ifndef SCHEDULE_H
-#define SCHEDULE_H
-
-#include "macros.h"
-#include "list.h"
-
-struct thread_info;
-
-/* ------------- This is modified by the programmer ------------ */
-/* sched_array is the primary data structure used by the scheduler.
- * We have left it to be modified by you so that you may 
- * implement any type of scheduler that you want.
- */
-struct sched_array {
-	struct list_head array;
-};
-
-/* ---------------- Do NOT Touch -------------- */
-/* Sleep Types */
-enum sleep_type
-{
-	SLEEP_NORMAL,
-	SLEEP_NONINTERACTIVE,
-	SLEEP_INTERACTIVE,
-	SLEEP_INTERRUPTED
-};
-
-/* task_struct */
-struct task_struct
-{
-	struct thread_info *thread_info;			/* Information about the thread */
-	int prio, static_prio, normal_prio;			/* Priority values */	
-	unsigned long sleep_avg;					/* The average time the task
-												   has been sleeping */
-	unsigned long long last_ran;				/* Timestamp for when the
-												   task was last run. */
-	unsigned long long timestamp;				/* A timestamp value */
-	unsigned long long sched_time;				/* The amount of time task
-												   was waiting to be scheduled */
-	unsigned int time_slice, first_time_slice;	/* Timeslice values */
-	struct list_head run_list;					/* Linked list for sched_array */
-	struct sched_array *array;					/* The sched_array the task is in */
-	enum sleep_type sleep_type;					/* What type of sleep task is in */
-	int need_reschedule;						/* Flag, set if task needs to
-												   have schedule called */
-};
-
-/* runqueue */
-struct runqueue {
-    unsigned long    nr_running;				/* number of runnable tasks */
-    unsigned long    nr_switches;				/* number of contextswitches */
-    unsigned long    expired_timestamp;			/* time of last array swap */
-	unsigned long long most_recent_timestamp;	/* The last time schedule was run */
-    struct task_struct *curr;					/* the currently running task */
-    struct sched_array  *active;				/* pointer to the active priority
-												   array */
-    struct sched_array  *expired;				/* pointer to the expired
-											       priority array */
-    struct sched_array  arrays[2];				/* the actual priority arrays */
-	int best_expired_prio;						/* The highest priority that has
-												 * expired thus far */
-};
-
-/*----------------------- System Calls ------------------------------*/
-/* These calls are provided by the VM for your
- * convenience, and mimic system calls provided
- * normally by Linux
- */
-void context_switch(struct task_struct *next); 
-unsigned long long sched_clock();
-
-/*------------------YOU MAY EDIT BELOW THIS LINE---------------------*/
-/*------------------- User Defined Functions -------------------------*/
-/*-------------These functions MUST be defined for the VM-------------*/
-void initschedule(struct runqueue *newrq, struct task_struct *seedTask);
-void killschedule();
-void schedule();
-void activate_task(struct task_struct *p);
-void deactivate_task(struct task_struct *p);
-void __activate_task(struct task_struct *p);
-void scheduler_tick(struct task_struct *p);
-void sched_fork(struct task_struct *p);
-void wake_up_new_task(struct task_struct *p);
-
-/*------------These functions are not necessary, but used----------------*
- *------------by linux normally for scheduling           ----------------*/
-void enqueue_task(struct task_struct *p, struct sched_array *array);
-void dequeue_task(struct task_struct *p, struct sched_array *array);
-
-#endif
diff --git a/Proj2/schedule.o b/Proj2/schedule.o
deleted file mode 100644
index 37ecbb6f512d3ba797b220afb1c34eab1c817cb3..0000000000000000000000000000000000000000
GIT binary patch
literal 0
Hc$@<O00001

literal 4552
zc$}q|UuauZ7{E`Gwu{}eWp$mC4ZV!5w6Ml@6q~qMZ&U7e5vOrb5UJeWCAT&<P1@wf
z*0EwCbQmw<zz1LUFnrNB-})r9OlJ^9+|ynr<iWwk`49ym4}p5lz2CVxIlae%9!S3L
z{=UEGPtI*WR9?Fr3<MAz0W^g=Pn~h<P)C>HJA(SrtXg}lR{xOH+J>#xDvcdtvdNcf
zDYjZi9aRn!eMj;fYD!DBuG*?Ki)B!)O~+L$6~<D=$X2WO;!a>KJ<L7Fxo6pt)(ZC9
zXwc$~x;z)~)MUS>#`|eYwO-=;!?(^Pte3skfskp{m4=hAuGk=(MAnt|9v-UI>sFI-
zX)>Y4lT}hgt=ckvvPl(7p4-|r-*DCV)^25psGW{%E1e|5nHDiPT|apa0xl`-@_^f|
z(gaph+D;X>B-_L#rEzTQ2I;K2(M0A9wI!6M`J!qKx{i2}tGfZUhNZR9garc|E>cTL
zMB+}m79)!HxP|u^cR@Z_uhwPzc_)hOpc9$)5(V8FLBDu1lPFDN2Rl`$M{U-2_SnKl
z#A(whfY%_%)FQa)y7*S<>JWR?<#g9nafh}~hs4zybH#ete%1@8XSqesGS{@%jn{Cq
zlb!rN+|97$<OAE;LfE&oWGU@hDrwEO-Gh+qJ{C+FoF4E0C+R(+xhJOOo~pw{g~P*7
z2(PhQ$*u2&CGM5}EezUoepW5p=PYy*3v)OIrZ|@lrHprT1u0j^nK5U1Ptbel#x)dJ
zj|M_V4ux;y#AlHEA>%&znm!u66`YCm0VB2~=mP@#9O#jNzx^iYvLOBr=tBbgHwVN&
z0zE0Pw?R(`>}TL&J};U-*i)kUgMD0JzX|q9(fq-FRy6+u?2o`c>SIS&W@cWJhOfLn
zJ0eZQ#$y+yi(_N)vB|LsY51Cvl~mny`RGJ^1ff{@gJn~{j-^?0<s#KeMqZDZ#=41O
zS>4o8?0UJ3Y0-Uftj40YP|}wT6w4HsmyH5;Efh^7hO3X3O+B-O{`Zg&a^9nT9G5}9
z($mekM|9eUIeCvlo}eoaL!B_#Pk|f)9^&FR{gV3Bx&S%<Yy3FW4+`RsaGd{}V@eQz
z8{%7BK$!DO`1C}^eAJbT5Kq>x5A9z+)u$&iK7tL6ah&&kQxLz+9|%GGakPK!*?9ec
zc)ztH<E?&I{sKm_4-vF~{!a<&4@X@2_W|`qgZTBJKll7>AwiaqZzqKNAI1>s-N(p0
zgE;>=nD-FyLEx_fmw`*bzXzTGJ_39X`1!87{+k<eR@0C3rxu|JMBZPWb+`|58h@fb
zIW7zMRmk%jq>_QZjmX*hYmZi@@*VJ}^#(w`C&*s}|A+7#fjaAg{F{P2pF*CGVLj<P
z{0{JQu=Oe6UjknMJ`Q{v_~*bUf!Bfm4E!wchrpX0e++y8j@Bq`w47NqvX#6M%b<L&
zY-)Noi!{ws9VKhzDI+TRtA>W5m5NzL%X&Uv%pjw%S}`hyX6of7R9Zz#xqRMpTqqfa
zR}Ez<r4o5TWr_vzPSeV3IWx0}vIdjEan=@!r6n(}q?tMV8e7ws46U-F6^u34Rnzp0
znR{P1A+-A`Yji&&_Z}jHTpR4K>Lf_AZRC~Y{5yolB*Tv}{4<6}8NS2t;|%{vz#lOD
zX@=8(VR`>s0{#WV2O0jg!2dgjpJe!t0{;_1f4(i?FNFO2nF{&)f5q_AZ2y8hzY6mF
z&Tw{L0zLluFZB55Nih5whD)$t{iyqWBy*hJJM$c;_sb^7>AiNB<Me*t<v6|H8yu(i
s4!v?Ir}w_ZaeD8|9H;lxJjdxhwaIaMPu=A>y{C3LPVcD($LT%w58ruO7XSbN

diff --git a/Proj2/schedule.old b/Proj2/schedule.old
deleted file mode 100644
index 02d4816..0000000
--- a/Proj2/schedule.old
+++ /dev/null
@@ -1,217 +0,0 @@
-/* schedule.c
- * This file contains the primary logic for the 
- * scheduler.
- */
-#include "schedule.h"
-#include "macros.h"
-#include <stddef.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-#define NEWTASKSLICE (NS_TO_JIFFIES(100000000))
-
-/* Local Globals
- * rq - This is a pointer to the runqueue that the scheduler uses.
- * current - A pointer to the current running task.
- */
-struct runqueue *rq;
-struct task_struct *current;
-
-/* External Globals
- * jiffies - A discrete unit of time used for scheduling.
- *			 There are HZ jiffies in a second, (HZ is 
- *			 declared in macros.h), and is usually
- *			 1 or 10 milliseconds.
- */
-extern long long jiffies;
-
-
-/*-----------------Initilization/Shutdown Code-------------------*/
-/* This code is not used by the scheduler, but by the virtual machine
- * to setup and destroy the scheduler cleanly.
- */
- 
- /* initscheduler
-  * Sets up and allocates memory for the scheduler, as well
-  * as sets initial values. This function should also
-  * set the initial effective priority for the "seed" task 
-  * and enqueu it in the scheduler.
-  * INPUT:
-  * newrq - A pointer to an allocated rq to assign to your
-  *			local rq.
-  * seedTask - A pointer to a task to seed the scheduler and start
-  * the simulation.
-  */
-
-void initschedule(struct runqueue *newrq, struct task_struct *seedTask)
-{
-    printf( "Begin init.\n" );
-    struct sched_array* actual;
-
-    newrq->nr_running = 1;
-    newrq->nr_switches = 0;
-
-    actual = malloc( 2 *  sizeof( struct sched_array ) );
-    newrq->arrays[ 0 ] = actual[ 0 ];
-
-    newrq->active = &newrq->arrays[ 0 ];
-    INIT_LIST_HEAD( &newrq->arrays[ 0 ].array );
-
-    enqueue_task( seedTask, newrq->active );
-
-    //seedTask->need_reschedule = 1;
-
-    seedTask->first_time_slice = NEWTASKSLICE;
-    seedTask->time_slice = NEWTASKSLICE;
-
-    rq = newrq;
-}
-
-/* killschedule
- * This function should free any memory that 
- * was allocated when setting up the runqueu.
- * It SHOULD NOT free the runqueue itself.
- */
-void killschedule()
-{
-    printf( "Begin Kill.\n" );
-
-    //free( rq->arrays );
-
-}
-
-/*-------------Scheduler Code Goes Below------------*/
-/* This is the beginning of the actual scheduling logic */
-
-/* schedule
- * Gets the next task with the shortest runtime(time slice) remaining
- */
-void schedule()
-{
-    //printf( "Calling schedule\n" );
-
-    struct list_head* pos = NULL;
-
-    struct task_struct *task = NULL;
-    struct task_struct *next = current;
-    
-    unsigned int rem_time = -1;
-  
-    list_for_each( pos, &rq->active->array )
-        {
-        task = list_entry( pos, struct task_struct, run_list );
-        task->need_reschedule = 0;
-        if( task->time_slice < rem_time )
-            {
-            rem_time = task->time_slice;
-            next = task;
-            }	
-        }
-    if( current != next )
-        {
-	rq->curr = next;
-        rq->nr_switches++;
-        context_switch( next );
-        }
-}
-
-
-/* enqueue_task
- * Enqeueus a task in the passed sched_array
- */
-void enqueue_task(struct task_struct *p, struct sched_array *array)
-{
-    //printf( "Calling enqueue_task\n" );
-    list_add( &p->run_list, &array->array );
-    p->array = array;
-    rq->nr_running++;
-}
-
-/* dequeue_task
- * Removes a task from the passed sched_array
- */
-void dequeue_task(struct task_struct *p, struct sched_array *array)
-{
-    //printf( "Calling dequue_task\n" );
-
-    list_del( &p->run_list );
-    p->array = NULL;   
-    rq->nr_running--;
-}
-
-/* sched_fork
- * Sets up schedule info for a newly forked task
- */
-void sched_fork(struct task_struct *p)
-{	
-    printf( "Calling sched_fork\n" );
-
-    p->first_time_slice = current->first_time_slice / 2;
-    p->time_slice = p->first_time_slice;
-}
-
-/* scheduler_tick
- * Updates information and priority
- * for the task that is currently running.
- */
-void scheduler_tick(struct task_struct *p)
-{	
-    p->time_slice--;
-    if( p->time_slice == 0 )
-    {
-        //printf( "A process has expired.\n" );
-        //dequeue_task( p, rq->active );
-        p->time_slice = p->first_time_slice;
-        p->need_reschedule = 1;
-        dequeue_task( p, rq->active );
-        //enqueue_task( p, rq->active );
-    }
-}
-
-/* wake_up_new_task
- * Prepares information for a task
- * that is waking up for the first time
- * (being created).
- * Also handles preemption, e.g. decides 
- * whether or not the current task should
- * call scheduler to allow for this one to run
- */
-void wake_up_new_task(struct task_struct *p)
-{	
-    printf( "Calling wake_up_new_task\n" );
-
-    enqueue_task( p, rq->active );
-    p->need_reschedule = 1;
-}
-
-/* __activate_task
- * Activates the task in the scheduler
- * by adding it to the active array.
- */
-void __activate_task(struct task_struct *p)
-{
-    enqueue_task( p, rq->active );
-}
-
-/* activate_task
- * Activates a task that is being woken-up
- * from sleeping.
- */
-void activate_task(struct task_struct *p)
-{	
-    printf( "Calling activate_task\n" );
-    __activate_task( p );
-}
-
-/* deactivate_task
- * Removes a running task from the scheduler to
- * put it to sleep.
- */
-void deactivate_task(struct task_struct *p)
-{
-    printf( "Calling deactivate_task\n" );
-
-    dequeue_task( p , rq->active);
-    printf( "deactive done\n" );
-}
diff --git a/Proj2/vmsched b/Proj2/vmsched
deleted file mode 100755
index aa97152b78865a68f23bd09fea49d6b4503679b7..0000000000000000000000000000000000000000
GIT binary patch
literal 0
Hc$@<O00001

literal 20452
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

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index 837ebd6..5970424 100644
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -1,3 +1,5 @@
+//CS 411 Group 2
+//Matt Thomas, Matt Martinson, Ian Crawford, Sarah Clisby
 /*
  * SLOB Allocator: Simple List Of Blocks
  *
-- 
1.5.2.1


From b07cc60805e911ad9514fbeb17fd8b5fab6a574e Mon Sep 17 00:00:00 2001
From: CrawfordI <crawfoia@onid.orst.edu>
Date: Thu, 4 Nov 2010 16:19:17 -0700
Subject: [PATCH] Added syscalls to table.

---
 linux-2.6.34.7/arch/x86/kernel/syscall_table_32.S |    2 +
 linux-2.6.34.7/mm/slob.c                          |   43 +++++++++++++++++++++
 2 files changed, 45 insertions(+), 0 deletions(-)

diff --git a/linux-2.6.34.7/arch/x86/kernel/syscall_table_32.S b/linux-2.6.34.7/arch/x86/kernel/syscall_table_32.S
index 8b37293..6d04a25 100644
--- a/linux-2.6.34.7/arch/x86/kernel/syscall_table_32.S
+++ b/linux-2.6.34.7/arch/x86/kernel/syscall_table_32.S
@@ -337,3 +337,5 @@ ENTRY(sys_call_table)
 	.long sys_rt_tgsigqueueinfo	/* 335 */
 	.long sys_perf_event_open
 	.long sys_recvmmsg
+	.long sys_get_slob_amt_claimed
+	.long sys_get_slob_amt_free
diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index 837ebd6..ae80e5c 100644
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -129,6 +129,12 @@ static LIST_HEAD(free_slob_medium);
 static LIST_HEAD(free_slob_large);
 
 /*
+ * The number of pages currently allocated.
+ */
+
+static unsigned int pages_alloc = 0;
+
+/*
  * is_slob_page: True for all slob pages (false for bigblock pages)
  */
 static inline int is_slob_page(struct slob_page *sp)
@@ -173,6 +179,7 @@ static inline void clear_slob_page_free(struct slob_page *sp)
 
 #define SLOB_UNIT sizeof(slob_t)
 #define SLOB_UNITS(size) (((size) + SLOB_UNIT - 1)/SLOB_UNIT)
+#define UNSLOB_UNITS(size) (SLOB_UNIT*((size) - SLOB_UNIT + 1))
 #define SLOB_ALIGN L1_CACHE_BYTES
 
 /*
@@ -379,6 +386,9 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 		b = slob_page_alloc(sp, size, align);
 		BUG_ON(!b);
 		spin_unlock_irqrestore(&slob_lock, flags);
+
+		/* Increment number of pages allocated. */
+		pages_alloc++;
 	}
 	if (unlikely((gfp & __GFP_ZERO) && b))
 		memset(b, 0, size);
@@ -399,6 +409,9 @@ static void slob_free(void *block, int size)
 		return;
 	BUG_ON(!size);
 
+	/* Decrement number of pages allocated. */
+	pages_alloc--;
+
 	sp = slob_page(block);
 	units = SLOB_UNITS(size);
 
@@ -697,3 +710,33 @@ void __init kmem_cache_init_late(void)
 {
 	/* Nothing to do */
 }
+
+unsigned int sys_get_slob_amt_claimed()
+{
+	return (pages_alloc * PAGE_SIZE);
+}
+
+unsigned int sys_get_slob_amt_free()
+{
+	struct list_head *slob_list;
+	struct slob_page *sp;
+
+	unsigned int free_bytes = 0;
+
+	slob_list = &free_slob_small;
+	list_for_each( sp, slob_list, list ){
+		free_bytes += UNSLOB_UNITS( sp->units );
+	}
+	 
+	slob_list = &free_slob_medium;
+	list_for_each( sp, slob_list, list ){
+		free_bytes += UNSLOB_UNITS( sp->units );
+	}
+
+	slob_list = &free_slob_large;
+	list_for_each( sp, slob_list, list ){
+		free_bytes += UNSLOB_UNITS( sp->units );
+	}
+
+	return free_bytes; 
+}
-- 
1.5.2.1


From ce8e3bfff39e80ea2841ff594ecf0ad3060571c4 Mon Sep 17 00:00:00 2001
From: Matt Thomas <baddack@gmail.com>
Date: Thu, 4 Nov 2010 16:31:53 -0700
Subject: [PATCH] Added syscalls to unistd_32

---
 linux-2.6.34.7/arch/x86/include/asm/unistd_32.h |    4 +++-
 1 files changed, 3 insertions(+), 1 deletions(-)

diff --git a/linux-2.6.34.7/arch/x86/include/asm/unistd_32.h b/linux-2.6.34.7/arch/x86/include/asm/unistd_32.h
index beb9b5f..47f17d8 100644
--- a/linux-2.6.34.7/arch/x86/include/asm/unistd_32.h
+++ b/linux-2.6.34.7/arch/x86/include/asm/unistd_32.h
@@ -343,10 +343,12 @@
 #define __NR_rt_tgsigqueueinfo	335
 #define __NR_perf_event_open	336
 #define __NR_recvmmsg		337
+#define __NR_sys_get_slob_amt_claimed 338
+#define __NR_sys_get_slob_amt_free 339
 
 #ifdef __KERNEL__
 
-#define NR_syscalls 338
+#define NR_syscalls 340
 
 #define __ARCH_WANT_IPC_PARSE_VERSION
 #define __ARCH_WANT_OLD_READDIR
-- 
1.5.2.1


From 890f1b9b01d691f93781820a9aff5820668ef92b Mon Sep 17 00:00:00 2001
From: CrawfordI <crawfoia@onid.orst.edu>
Date: Thu, 4 Nov 2010 17:00:51 -0700
Subject: [PATCH] fixed syscalls

---
 linux-2.6.34.7/mm/slob.c |    6 +++---
 1 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index afe674d..81e0893 100644
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -726,17 +726,17 @@ unsigned int sys_get_slob_amt_free()
 	unsigned int free_bytes = 0;
 
 	slob_list = &free_slob_small;
-	list_for_each( sp, slob_list, list ){
+	list_for_each_entry( sp, slob_list, list ){
 		free_bytes += UNSLOB_UNITS( sp->units );
 	}
 	 
 	slob_list = &free_slob_medium;
-	list_for_each( sp, slob_list, list ){
+	list_for_each_entry( sp, slob_list, list ){
 		free_bytes += UNSLOB_UNITS( sp->units );
 	}
 
 	slob_list = &free_slob_large;
-	list_for_each( sp, slob_list, list ){
+	list_for_each_entry( sp, slob_list, list ){
 		free_bytes += UNSLOB_UNITS( sp->units );
 	}
 
-- 
1.5.2.1


From 65abec96abec46f5a05bac05d066048d26931106 Mon Sep 17 00:00:00 2001
From: martinm2 <martinm2@onid.orst.edu>
Date: Thu, 4 Nov 2010 17:19:58 -0700
Subject: [PATCH] Added simple program

---
 linux-2.6.34.7/simple/simple   |  Bin 0 -> 6943 bytes
 linux-2.6.34.7/simple/simple.c |   19 +++++++++++++++++++
 2 files changed, 19 insertions(+), 0 deletions(-)
 create mode 100755 linux-2.6.34.7/simple/simple
 create mode 100644 linux-2.6.34.7/simple/simple.c

diff --git a/linux-2.6.34.7/simple/simple b/linux-2.6.34.7/simple/simple
new file mode 100755
index 0000000000000000000000000000000000000000..e9bbfefaf832e4abc46bbd8d5fa78b95d14f34c1
GIT binary patch
literal 6943
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

literal 0
Hc$@<O00001

diff --git a/linux-2.6.34.7/simple/simple.c b/linux-2.6.34.7/simple/simple.c
new file mode 100644
index 0000000..ab3de64
--- /dev/null
+++ b/linux-2.6.34.7/simple/simple.c
@@ -0,0 +1,19 @@
+#include <unistd.h>
+#include <stdio.h>
+//#include <arch/x86/include/asm/unistd_32.h>
+//#include <unistd_32.h>
+
+
+int main( int argc, char ** argv ) {
+
+  unsigned int free, claimed;
+
+  claimed = syscall( /*__NR_sys_get_slob_amt_claimed*/ 338 );
+  free = syscall( /*__NR_sys_get_slob_amt_free*/ 339 );
+
+  printf( "Claimed memory: %d\n", claimed );
+  printf( "Free memory: %d\n", free );
+
+  return 0;
+
+}
-- 
1.5.2.1


From 71bbc26e6745c278aedeeeb91e1ee5c36ab6e094 Mon Sep 17 00:00:00 2001
From: martinm2 <martinm2@onid.orst.edu>
Date: Thu, 4 Nov 2010 17:32:27 -0700
Subject: [PATCH] Fixed simple program so that it was printing unsinged ints

---
 linux-2.6.34.7/simple/simple   |  Bin 6943 -> 6943 bytes
 linux-2.6.34.7/simple/simple.c |    4 ++--
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/linux-2.6.34.7/simple/simple b/linux-2.6.34.7/simple/simple
index e9bbfefaf832e4abc46bbd8d5fa78b95d14f34c1..69422b10d92e7047dbdc4d597a3f915eccede0da 100755
GIT binary patch
delta 31
mc$}MWHs5SRB%4qv7lT_-YN|qRYHof}rImte>E>*<Eg}G>WeR2h

delta 31
mc$}MWHs5SRB%4qQ7lT_-YN|qRYHof}rImte%I0jgEg}G<cnU-S

diff --git a/linux-2.6.34.7/simple/simple.c b/linux-2.6.34.7/simple/simple.c
index ab3de64..b1ca791 100644
--- a/linux-2.6.34.7/simple/simple.c
+++ b/linux-2.6.34.7/simple/simple.c
@@ -11,8 +11,8 @@ int main( int argc, char ** argv ) {
   claimed = syscall( /*__NR_sys_get_slob_amt_claimed*/ 338 );
   free = syscall( /*__NR_sys_get_slob_amt_free*/ 339 );
 
-  printf( "Claimed memory: %d\n", claimed );
-  printf( "Free memory: %d\n", free );
+  printf( "Claimed memory: %u\n", claimed );
+  printf( "Free memory: %u\n", free );
 
   return 0;
 
-- 
1.5.2.1


From 3db4b2119cbfbbf2f62338a1df3f089723ace3e1 Mon Sep 17 00:00:00 2001
From: martinm2 <martinm2@onid.orst.edu>
Date: Sat, 6 Nov 2010 14:39:45 -0700
Subject: [PATCH] Adding debug printk statements to slob.c syscalls

---
 linux-2.6.34.7/mm/slob.c |    3 +++
 1 files changed, 3 insertions(+), 0 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index 81e0893..7e708f6 100644
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -715,7 +715,10 @@ void __init kmem_cache_init_late(void)
 
 unsigned int sys_get_slob_amt_claimed()
 {
+        printk( "Amount claimed is\t\tpages_alloc: %u\n", pages_alloc );
+	printk( "PAGE_SIZE in int: %d, uint: %u, float: %f\n", PAGE_SIZE, PAGE_SIZE, PAGE_SIZE" );
 	return (pages_alloc * PAGE_SIZE);
+	
 }
 
 unsigned int sys_get_slob_amt_free()
-- 
1.5.2.1


From a4b9ef673e148fdfb7bc69cf34d549b3ee29a5fc Mon Sep 17 00:00:00 2001
From: martinm2 <martinm2@onid.orst.edu>
Date: Sat, 6 Nov 2010 15:16:59 -0700
Subject: [PATCH] Fixed my fail in printk statements

---
 linux-2.6.34.7/mm/slob.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index 7e708f6..d0685c9 100644
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -716,7 +716,7 @@ void __init kmem_cache_init_late(void)
 unsigned int sys_get_slob_amt_claimed()
 {
         printk( "Amount claimed is\t\tpages_alloc: %u\n", pages_alloc );
-	printk( "PAGE_SIZE in int: %d, uint: %u, float: %f\n", PAGE_SIZE, PAGE_SIZE, PAGE_SIZE" );
+	printk( "PAGE_SIZE in int: %lu\n", PAGE_SIZE );
 	return (pages_alloc * PAGE_SIZE);
 	
 }
-- 
1.5.2.1


From fbb2fb737b272e6fead2237e107bb380b5e933e3 Mon Sep 17 00:00:00 2001
From: martinm2 <martinm2@onid.orst.edu>
Date: Sat, 6 Nov 2010 15:26:30 -0700
Subject: [PATCH] Added level to printk

---
 linux-2.6.34.7/mm/slob.c |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index d0685c9..9e51f3c 100644
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -715,8 +715,8 @@ void __init kmem_cache_init_late(void)
 
 unsigned int sys_get_slob_amt_claimed()
 {
-        printk( "Amount claimed is\t\tpages_alloc: %u\n", pages_alloc );
-	printk( "PAGE_SIZE in int: %lu\n", PAGE_SIZE );
+        printk( KERN_ALERT "Amount claimed is\t\tpages_alloc: %u\n", pages_alloc );
+	printk( KERN_ALERT "PAGE_SIZE in int: %lu\n", PAGE_SIZE );
 	return (pages_alloc * PAGE_SIZE);
 	
 }
-- 
1.5.2.1


From 268606f01b27c56a8357d337740681cf2da2c1d2 Mon Sep 17 00:00:00 2001
From: martinm2 <martinm2@onid.orst.edu>
Date: Sat, 6 Nov 2010 15:38:41 -0700
Subject: [PATCH] Casting PAGE_SIZE to unsigned int

---
 linux-2.6.34.7/mm/slob.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index 9e51f3c..1aa8873 100644
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -717,7 +717,7 @@ unsigned int sys_get_slob_amt_claimed()
 {
         printk( KERN_ALERT "Amount claimed is\t\tpages_alloc: %u\n", pages_alloc );
 	printk( KERN_ALERT "PAGE_SIZE in int: %lu\n", PAGE_SIZE );
-	return (pages_alloc * PAGE_SIZE);
+	return (pages_alloc * (unsigned int)PAGE_SIZE);
 	
 }
 
-- 
1.5.2.1


From b570b888b2c75678bb1bcaf08abc992dfa1e8526 Mon Sep 17 00:00:00 2001
From: martinm2 <martinm2@onid.orst.edu>
Date: Sat, 6 Nov 2010 15:51:21 -0700
Subject: [PATCH] pages_alloc hates us

---
 linux-2.6.34.7/mm/slob.c |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index 1aa8873..d6c5433 100644
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -412,7 +412,7 @@ static void slob_free(void *block, int size)
 	BUG_ON(!size);
 
 	/* Decrement number of pages allocated. */
-	pages_alloc--;
+	//pages_alloc--; //CHINGAS
 
 	sp = slob_page(block);
 	units = SLOB_UNITS(size);
@@ -715,7 +715,7 @@ void __init kmem_cache_init_late(void)
 
 unsigned int sys_get_slob_amt_claimed()
 {
-        printk( KERN_ALERT "Amount claimed is\t\tpages_alloc: %u\n", pages_alloc );
+        printk( KERN_ALERT "Amount pages_alloc: %u\n", pages_alloc );
 	printk( KERN_ALERT "PAGE_SIZE in int: %lu\n", PAGE_SIZE );
 	return (pages_alloc * (unsigned int)PAGE_SIZE);
 	
-- 
1.5.2.1


From fb640b62362a045172b2fd2aa78fcd71c3463a2e Mon Sep 17 00:00:00 2001
From: martinm2 <martinm2@onid.orst.edu>
Date: Sat, 6 Nov 2010 16:00:55 -0700
Subject: [PATCH] moved pages_alloc-- to OUT!

---
 linux-2.6.34.7/mm/slob.c |    9 +++++----
 1 files changed, 5 insertions(+), 4 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index d6c5433..2f61c47 100644
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -411,9 +411,6 @@ static void slob_free(void *block, int size)
 		return;
 	BUG_ON(!size);
 
-	/* Decrement number of pages allocated. */
-	//pages_alloc--; //CHINGAS
-
 	sp = slob_page(block);
 	units = SLOB_UNITS(size);
 
@@ -476,6 +473,9 @@ static void slob_free(void *block, int size)
 	}
 out:
 	spin_unlock_irqrestore(&slob_lock, flags);
+
+	/* Decrement number of pages allocated. */
+	pages_alloc--; //CHINGAS
 }
 
 /*
@@ -579,7 +579,8 @@ struct kmem_cache {
 struct kmem_cache *kmem_cache_create(const char *name, size_t size,
 	size_t align, unsigned long flags, void (*ctor)(void *))
 {
-	struct kmem_cache *c;
+	struct kmem_cache *c;/* Decrement number of pages allocated. */
+	//pages_alloc--; //CHINGAS
 
 	c = slob_alloc(sizeof(struct kmem_cache),
 		GFP_KERNEL, ARCH_KMALLOC_MINALIGN, -1);
-- 
1.5.2.1


From 8d13db60f39749b45443bc68c718de3eda9142ea Mon Sep 17 00:00:00 2001
From: martinm2 <martinm2@onid.orst.edu>
Date: Sat, 6 Nov 2010 16:20:01 -0700
Subject: [PATCH] Moved the -- again

---
 linux-2.6.34.7/mm/slob.c |    5 +++--
 1 files changed, 3 insertions(+), 2 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index 2f61c47..b1c6683 100644
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -422,6 +422,8 @@ static void slob_free(void *block, int size)
 			clear_slob_page_free(sp);
 		spin_unlock_irqrestore(&slob_lock, flags);
 		clear_slob_page(sp);
+		/* Decrement number of pages allocated. */
+		pages_alloc--; //CHINGAS
 		free_slob_page(sp);
 		slob_free_pages(b, 0);
 		return;
@@ -474,8 +476,7 @@ static void slob_free(void *block, int size)
 out:
 	spin_unlock_irqrestore(&slob_lock, flags);
 
-	/* Decrement number of pages allocated. */
-	pages_alloc--; //CHINGAS
+	
 }
 
 /*
-- 
1.5.2.1


From 5513964f4449cf0bf72e5530fcdaddecc04f8a84 Mon Sep 17 00:00:00 2001
From: CrawfordI <crawfoia@onid.orst.edu>
Date: Sat, 6 Nov 2010 16:27:20 -0700
Subject: [PATCH] Moved increment of pages_alloc

---
 linux-2.6.34.7/mm/slob.c |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index b1c6683..1569f5c 100644
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -260,7 +260,7 @@ static void *slob_new_pages(gfp_t gfp, int order, int node)
 
 	if (!page)
 		return NULL;
-
+	pages_alloc++;
 	return page_address(page);
 }
 
@@ -390,7 +390,7 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 		spin_unlock_irqrestore(&slob_lock, flags);
 
 		/* Increment number of pages allocated. */
-		pages_alloc++;
+		//pages_alloc++;
 	}
 	if (unlikely((gfp & __GFP_ZERO) && b))
 		memset(b, 0, size);
-- 
1.5.2.1


From 9d1bdecfcb365bbc415be813df77028a165031bf Mon Sep 17 00:00:00 2001
From: CrawfordI <crawfoia@onid.orst.edu>
Date: Sat, 6 Nov 2010 16:45:43 -0700
Subject: [PATCH] Merged page lists.

---
 linux-2.6.34.7/mm/slob.c |   10 +++++-----
 1 files changed, 5 insertions(+), 5 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index 1569f5c..670f83a 100644
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -333,12 +333,12 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 	slob_t *b = NULL;
 	unsigned long flags;
 
-	if (size < SLOB_BREAK1)
+	//if (size < SLOB_BREAK1)
 		slob_list = &free_slob_small;
-	else if (size < SLOB_BREAK2)
-		slob_list = &free_slob_medium;
-	else
-		slob_list = &free_slob_large;
+	//else if (size < SLOB_BREAK2)
+	//	slob_list = &free_slob_medium;
+	//else
+	//	slob_list = &free_slob_large;
 
 	spin_lock_irqsave(&slob_lock, flags);
 	/* Iterate through each partially free page, try to find room */
-- 
1.5.2.1


From 0658cb19993d2e7df8bd85fc38c45a7e5862f484 Mon Sep 17 00:00:00 2001
From: Matt Thomas <baddack@gmail.com>
Date: Sat, 6 Nov 2010 17:15:53 -0700
Subject: [PATCH] Started find_best_fit_block()

---
 linux-2.6.34.7/mm/slob.c |    9 ++++++++-
 1 files changed, 8 insertions(+), 1 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index 1569f5c..fc1a9ea 100644
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -272,6 +272,13 @@ static void slob_free_pages(void *b, int order)
 }
 
 /*
+ * Finds best fit block in a given slob_page sp.
+*/
+static void find_best_fit_block(struct slob_page *sp, size_t size, int align)
+{
+	//code here
+}
+/*
  * Allocate a slob block within a given slob_page sp.
  */
 static void *slob_page_alloc(struct slob_page *sp, size_t size, int align)
@@ -280,7 +287,7 @@ static void *slob_page_alloc(struct slob_page *sp, size_t size, int align)
 	int delta = 0, units = SLOB_UNITS(size);
 
 	for (prev = NULL, cur = sp->free; ; prev = cur, cur = slob_next(cur)) {
-		slobidx_t avail = slob_units(cur);
+	slobidx_t avail = slob_units(cur);
 
 		if (align) {
 			aligned = (slob_t *)ALIGN((unsigned long)cur, align);
-- 
1.5.2.1


From 0e68192547534c1f7df732da2e1690a9e672e8a3 Mon Sep 17 00:00:00 2001
From: ClisbyS <clisbys@onid.orst.edu>
Date: Sat, 6 Nov 2010 17:25:36 -0700
Subject: [PATCH] Created best_block structure

---
 linux-2.6.34.7/mm/slob.c |    8 ++++++++
 1 files changed, 8 insertions(+), 0 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index 1569f5c..c10c7e7 100644
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -91,6 +91,14 @@ struct slob_block {
 };
 typedef struct slob_block slob_t;
 
+struct best_block {
+	int object_size;	/* Size of thing we're allocating */
+	slobidx_t block_size;	/* Size of block */
+	slob_t *prev		/* Previous block */
+	slob_t *cur		/* Current block (the best one) */
+	slob_t *next		/* Next block */
+};
+
 /*
  * We use struct page fields to manage some slob allocation aspects,
  * however to avoid the horrible mess in include/linux/mm_types.h, we'll
-- 
1.5.2.1


From 5366a0bdde0e3f796a8047e26584e863c31d902a Mon Sep 17 00:00:00 2001
From: ClisbyS <clisbys@onid.orst.edu>
Date: Sat, 6 Nov 2010 18:03:17 -0700
Subject: [PATCH] Fleshing out find_best_fit_slob

---
 linux-2.6.34.7/mm/slob.c |   64 ++++++++++++++++++++++++++++++++++++++++++++-
 1 files changed, 62 insertions(+), 2 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index 2346ef2..89964c4 100644
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -91,6 +91,7 @@ struct slob_block {
 };
 typedef struct slob_block slob_t;
 
+/* Keeps track of the best-fit block */
 struct best_block {
 	int object_size;	/* Size of thing we're allocating */
 	slobidx_t block_size;	/* Size of block */
@@ -282,10 +283,69 @@ static void slob_free_pages(void *b, int order)
 /*
  * Finds best fit block in a given slob_page sp.
 */
-static void find_best_fit_block(struct slob_page *sp, size_t size, int align)
+static void find_best_fit_block(struct slob_page *sp, struct best_block *best, size_t size, int align)
 {
-	//code here
+	slob_t *prev, *cur, *aligned = NULL;
+        int delta = 0, units = SLOB_UNITS(size);
+
+        for (prev = NULL, cur = sp->free; ; prev = cur, cur = slob_next(cur)) {
+        slobidx_t avail = slob_units(cur);
+
+                if (align) {
+                        aligned = (slob_t *)ALIGN((unsigned long)cur, align);
+                        delta = aligned - cur;
+                }
+
+                if (avail >= units + delta) { /* room enough? */
+                        slob_t *next;
+
+/*
+                        if (delta) { // need to fragment head to align?
+                                next = slob_next(cur);
+                                set_slob(aligned, avail - delta, next);
+                                set_slob(cur, delta, aligned);
+                                prev = cur;
+                                cur = aligned;
+                                avail = slob_units(cur);
+                        }
+*/
+
+                        next = slob_next(cur);
+                        if (avail == units) { /* exact fit? unlink. */
+                                //if (prev)
+					best_block->prev = prev;
+					best_block->cur = cur;
+					best_block->next = next;
+					best_block->object_size = units;
+					best_block->block_size = avail;
+                                	// set_slob(prev, slob_units(prev), next);
+                                //else
+                                  //      sp->free = next;
+                        } else { /* fragment */
+                                //if (prev)
+                                  //      set_slob(prev, slob_units(prev), cur + units);
+                                //else
+                                //       sp->free = cur + units;
+                                //set_slob(cur + units, avail - units, next);
+				if ((avail - units) < (best_block->block_size - best_block->object_size)) {
+					best_block->prev = prev;
+                                        best_block->cur = cur;
+                                        best_block->next = next;
+                                        best_block->object_size = units;
+                                        best_block->block_size = avail;
+				}
+                        }
+
+                        //sp->units -= units;
+                        //if (!sp->units)
+                        //        clear_slob_page_free(sp);
+                        //return cur;
+                }
+                if (slob_last(cur))
+                        return NULL;
+        }
 }
+
 /*
  * Allocate a slob block within a given slob_page sp.
  */
-- 
1.5.2.1


From e78041bc0117baff014e815ae7c5b661cefdf4e1 Mon Sep 17 00:00:00 2001
From: Matt Thomas <baddack@gmail.com>
Date: Sat, 6 Nov 2010 18:06:40 -0700
Subject: [PATCH] fixing broken git

---
 linux-2.6.34.7/mm/slob.c |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index e48882a..b3311c2 100644
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -278,6 +278,7 @@ static void find_best_fit_block(struct slob_page *sp, size_t size, int align)
 {
 	//code here
 }
+
 /*
  * Allocate a slob block within a given slob_page sp.
  */
-- 
1.5.2.1


From 4bf4fbcf111b8f7af507d9d504beb199779ed08b Mon Sep 17 00:00:00 2001
From: Matt Thomas <baddack@gmail.com>
Date: Sat, 6 Nov 2010 18:54:14 -0700
Subject: [PATCH] Worked on changing slob_alloc for best fit

---
 linux-2.6.34.7/mm/slob.c |   28 ++++++++++++++++++++--------
 1 files changed, 20 insertions(+), 8 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index 89964c4..f6c1661 100644
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -407,13 +407,21 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 	struct list_head *slob_list;
 	slob_t *b = NULL;
 	unsigned long flags;
-
+	
 	//if (size < SLOB_BREAK1)
 		slob_list = &free_slob_small;
 	//else if (size < SLOB_BREAK2)
 	//	slob_list = &free_slob_medium;
 	//else
 	//	slob_list = &free_slob_large;
+	
+	struct best = best_block;
+	//this could be bad
+	best->block_size = PAGE_SIZE + 1;
+	best->object_size = size;
+	best->prev = NULL;
+	best->cur = NULL;
+	best->next = NULL;
 
 	spin_lock_irqsave(&slob_lock, flags);
 	/* Iterate through each partially free page, try to find room */
@@ -432,17 +440,21 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 
 		/* Attempt to alloc */
 		prev = sp->list.prev;
-		b = slob_page_alloc(sp, size, align);
-		if (!b)
-			continue;
+		//b = slob_page_alloc(sp, size, align);
+		find_best_fit_block(sp, best, size, align);
+		if((best->block_size - best->object_size) == 0){
+			break;
+		}
+		//if (!b)
+		//	continue;
 
 		/* Improve fragment distribution and reduce our average
 		 * search time by starting our next search here. (see
 		 * Knuth vol 1, sec 2.5, pg 449) */
-		if (prev != slob_list->prev &&
-				slob_list->next != prev->next)
-			list_move_tail(slob_list, prev->next);
-		break;
+		//if (prev != slob_list->prev &&
+		//		slob_list->next != prev->next)
+		//	list_move_tail(slob_list, prev->next);
+		//break;
 	}
 	spin_unlock_irqrestore(&slob_lock, flags);
 
-- 
1.5.2.1


From 27d260dabe2eb24f0db7cfdbb49a95254b08d5a3 Mon Sep 17 00:00:00 2001
From: martinm2 <martinm2@onid.orst.edu>
Date: Sat, 6 Nov 2010 19:51:16 -0700
Subject: [PATCH] moar stuffs

---
 linux-2.6.34.7/mm/slob.c |   83 +++++++++++++++++++++++++++++++++++++++------
 1 files changed, 72 insertions(+), 11 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index f6c1661..dd80636 100644
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -98,6 +98,7 @@ struct best_block {
 	slob_t *prev		/* Previous block */
 	slob_t *cur		/* Current block (the best one) */
 	slob_t *next		/* Next block */
+	slob_page *page		/* Page with best fit */
 };
 
 /*
@@ -313,11 +314,12 @@ static void find_best_fit_block(struct slob_page *sp, struct best_block *best, s
                         next = slob_next(cur);
                         if (avail == units) { /* exact fit? unlink. */
                                 //if (prev)
-					best_block->prev = prev;
-					best_block->cur = cur;
-					best_block->next = next;
-					best_block->object_size = units;
-					best_block->block_size = avail;
+					best->prev = prev;
+					best->cur = cur;
+					best->next = next;
+					best->object_size = units;
+					best->block_size = avail;
+					best->page = sp;
                                 	// set_slob(prev, slob_units(prev), next);
                                 //else
                                   //      sp->free = next;
@@ -328,11 +330,12 @@ static void find_best_fit_block(struct slob_page *sp, struct best_block *best, s
                                 //       sp->free = cur + units;
                                 //set_slob(cur + units, avail - units, next);
 				if ((avail - units) < (best_block->block_size - best_block->object_size)) {
-					best_block->prev = prev;
-                                        best_block->cur = cur;
-                                        best_block->next = next;
-                                        best_block->object_size = units;
-                                        best_block->block_size = avail;
+					best->prev = prev;
+                                        best->cur = cur;
+                                        best->next = next;
+                                        best->object_size = units;
+                                        best->block_size = avail;
+					best->page = sp;
 				}
                         }
 
@@ -458,8 +461,66 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 	}
 	spin_unlock_irqrestore(&slob_lock, flags);
 
+	/* Sommit found */
+	if (best->cur != NULL) {
+		if(align) {
+			aligned = (slob_t *) ALIGN ((unsigned long)cur, align);
+			delta = aligned - cur;
+		}
+		//if (
+/*slob_t *prev, *cur, *aligned = NULL;
+	int delta = 0, units = SLOB_UNITS(size);
+
+	for (prev = NULL, cur = sp->free; ; prev = cur, cur = slob_next(cur)) {
+	slobidx_t avail = slob_units(cur);
+
+		if (align) {
+			aligned = (slob_t *)ALIGN((unsigned long)cur, align);
+			delta = aligned - cur;
+		}*/
+		//if (avail >= units + delta) { /* room enough? */
+		slob_t *next;
+		cur = best -> cur;
+		prev = best -> prev;
+		sp = best -> page;
+
+		if (delta) { /* need to fragment head to align? */
+			next = slob_next(cur);
+			set_slob(aligned, avail - delta, next);
+			set_slob(cur, delta, aligned);
+			prev = cur;
+			cur = aligned;
+			avail = slob_units(cur);
+		}
+
+		next = slob_next(cur);
+		if (avail == units) { /* exact fit? unlink. */
+			if (prev)
+				set_slob(prev, slob_units(prev), next);
+			else
+				sp->free = next;
+		} else { /* fragment */
+			if (prev)
+				set_slob(prev, slob_units(prev), cur + units);
+			else
+				sp->free = cur + units;
+			set_slob(cur + units, avail - units, next);
+		}
+
+		sp->units -= units;
+		if (!sp->units)
+			clear_slob_page_free(sp);
+		//return cur;
+	//}
+	//if (slob_last(cur))
+		//return NULL;
+	}
+			
+		
+
+
 	/* Not enough space: must allocate a new page */
-	if (!b) {
+	if (best->block_size == PAGE_SIZE + 1) {
 		b = slob_new_pages(gfp & ~__GFP_ZERO, 0, node);
 		if (!b)
 			return NULL;
-- 
1.5.2.1


From 211806c19ee2ed05dec8a6f935269c11cca2f92d Mon Sep 17 00:00:00 2001
From: martinm2 <martinm2@onid.orst.edu>
Date: Sat, 6 Nov 2010 20:23:40 -0700
Subject: [PATCH] Finished base implementation of new manager of memory

---
 linux-2.6.34.7/mm/slob.c |   19 ++++++++++++++-----
 1 files changed, 14 insertions(+), 5 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index dd80636..2d55bd8 100644
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -300,16 +300,25 @@ static void find_best_fit_block(struct slob_page *sp, struct best_block *best, s
                 if (avail >= units + delta) { /* room enough? */
                         slob_t *next;
 
-/*
+
                         if (delta) { // need to fragment head to align?
-                                next = slob_next(cur);
+                                /*next = slob_next(cur);
                                 set_slob(aligned, avail - delta, next);
                                 set_slob(cur, delta, aligned);
                                 prev = cur;
                                 cur = aligned;
-                                avail = slob_units(cur);
+                                avail = slob_units(cur);*/
+				if((avail - units) < (best->block_size - best->object_size)) {
+					best->prev = prev;
+					best->cur = cur;
+					best->next = next;
+					best->object_size = units;
+					best->block_size = avail;
+					best->page = sp;
+				}
+				
                         }
-*/
+
 
                         next = slob_next(cur);
                         if (avail == units) { /* exact fit? unlink. */
@@ -329,7 +338,7 @@ static void find_best_fit_block(struct slob_page *sp, struct best_block *best, s
                                 //else
                                 //       sp->free = cur + units;
                                 //set_slob(cur + units, avail - units, next);
-				if ((avail - units) < (best_block->block_size - best_block->object_size)) {
+				if ((avail - units) < (best->block_size - best->object_size)) {
 					best->prev = prev;
                                         best->cur = cur;
                                         best->next = next;
-- 
1.5.2.1


From 88266e0f385cec9871462354012c162f9edf3370 Mon Sep 17 00:00:00 2001
From: martinm2 <martinm2@onid.orst.edu>
Date: Sat, 6 Nov 2010 20:31:06 -0700
Subject: [PATCH] Finished base implementation of new manager of memory

---
 linux-2.6.34.7/mm/slob.c |    3 ++-
 1 files changed, 2 insertions(+), 1 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index 2d55bd8..502fb4c 100644
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -419,6 +419,7 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 	struct list_head *slob_list;
 	slob_t *b = NULL;
 	unsigned long flags;
+	struct best = best_block;
 	
 	//if (size < SLOB_BREAK1)
 		slob_list = &free_slob_small;
@@ -427,7 +428,7 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 	//else
 	//	slob_list = &free_slob_large;
 	
-	struct best = best_block;
+	
 	//this could be bad
 	best->block_size = PAGE_SIZE + 1;
 	best->object_size = size;
-- 
1.5.2.1


From dac41341874cbca14ca82f9d1076678d3fa02050 Mon Sep 17 00:00:00 2001
From: martinm2 <martinm2@onid.orst.edu>
Date: Sat, 6 Nov 2010 20:38:09 -0700
Subject: [PATCH] Debugging build errors(take one)

---
 linux-2.6.34.7/mm/slob.c |   14 ++++++++++----
 1 files changed, 10 insertions(+), 4 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index 502fb4c..c8bafb3 100644
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -101,6 +101,10 @@ struct best_block {
 	slob_page *page		/* Page with best fit */
 };
 
+/* Function prototypes for system calls */
+unsigned int sys_get_slob_amt_claimed();
+unsigned int sys_get_slob_amt_free();
+
 /*
  * We use struct page fields to manage some slob allocation aspects,
  * however to avoid the horrible mess in include/linux/mm_types.h, we'll
@@ -420,6 +424,7 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 	slob_t *b = NULL;
 	unsigned long flags;
 	struct best = best_block;
+	slobidx_t avail;
 	
 	//if (size < SLOB_BREAK1)
 		slob_list = &free_slob_small;
@@ -493,6 +498,7 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 		cur = best -> cur;
 		prev = best -> prev;
 		sp = best -> page;
+		avail = best->block_size;
 
 		if (delta) { /* need to fragment head to align? */
 			next = slob_next(cur);
@@ -504,7 +510,7 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 		}
 
 		next = slob_next(cur);
-		if (avail == units) { /* exact fit? unlink. */
+		if (avail == size) { /* exact fit? unlink. */
 			if (prev)
 				set_slob(prev, slob_units(prev), next);
 			else
@@ -513,11 +519,11 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 			if (prev)
 				set_slob(prev, slob_units(prev), cur + units);
 			else
-				sp->free = cur + units;
-			set_slob(cur + units, avail - units, next);
+				sp->free = cur + size;
+			set_slob(cur + size, avail - size, next);
 		}
 
-		sp->units -= units;
+		sp->units -= size;
 		if (!sp->units)
 			clear_slob_page_free(sp);
 		//return cur;
-- 
1.5.2.1


From 6b58450271e2b57083ee3cc58819273c6acc6a54 Mon Sep 17 00:00:00 2001
From: martinm2 <martinm2@onid.orst.edu>
Date: Sat, 6 Nov 2010 20:40:49 -0700
Subject: [PATCH] Debugging build errors(take two)

---
 linux-2.6.34.7/mm/slob.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index c8bafb3..b9e3add 100644
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -423,7 +423,7 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 	struct list_head *slob_list;
 	slob_t *b = NULL;
 	unsigned long flags;
-	struct best = best_block;
+	struct best = best_block();
 	slobidx_t avail;
 	
 	//if (size < SLOB_BREAK1)
-- 
1.5.2.1


From 9413e15df5a6e8c0e48a91d99edf04b9d83d2793 Mon Sep 17 00:00:00 2001
From: martinm2 <martinm2@onid.orst.edu>
Date: Sat, 6 Nov 2010 20:44:05 -0700
Subject: [PATCH] Debugging build errors(take three)

---
 linux-2.6.34.7/mm/slob.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index b9e3add..a7a2df7 100644
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -423,7 +423,7 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 	struct list_head *slob_list;
 	slob_t *b = NULL;
 	unsigned long flags;
-	struct best = best_block();
+	struct best_block best;
 	slobidx_t avail;
 	
 	//if (size < SLOB_BREAK1)
-- 
1.5.2.1


From 19700f3285570134a15fa3ad0d103e937e6bbd2c Mon Sep 17 00:00:00 2001
From: martinm2 <martinm2@onid.orst.edu>
Date: Sun, 7 Nov 2010 17:59:45 -0800
Subject: [PATCH] Fixing more build errors (take...unknown)

---
 linux-2.6.34.7/mm/slob.c |   28 ++++++++++++++--------------
 1 files changed, 14 insertions(+), 14 deletions(-)
 mode change 100644 => 100755 linux-2.6.34.7/mm/slob.c

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
old mode 100644
new mode 100755
index a7a2df7..c2abae4
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -435,11 +435,11 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 	
 	
 	//this could be bad
-	best->block_size = PAGE_SIZE + 1;
-	best->object_size = size;
-	best->prev = NULL;
-	best->cur = NULL;
-	best->next = NULL;
+	best.block_size = PAGE_SIZE + 1;
+	best.object_size = size;
+	best.prev = NULL;
+	best.cur = NULL;
+	best.next = NULL;
 
 	spin_lock_irqsave(&slob_lock, flags);
 	/* Iterate through each partially free page, try to find room */
@@ -459,8 +459,8 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 		/* Attempt to alloc */
 		prev = sp->list.prev;
 		//b = slob_page_alloc(sp, size, align);
-		find_best_fit_block(sp, best, size, align);
-		if((best->block_size - best->object_size) == 0){
+		find_best_fit_block(sp, &best, size, align);
+		if((best.block_size - best.object_size) == 0){
 			break;
 		}
 		//if (!b)
@@ -477,10 +477,10 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 	spin_unlock_irqrestore(&slob_lock, flags);
 
 	/* Sommit found */
-	if (best->cur != NULL) {
+	if (best.cur != NULL) {
 		if(align) {
 			aligned = (slob_t *) ALIGN ((unsigned long)cur, align);
-			delta = aligned - cur;
+			delta = aligned - best.cur;
 		}
 		//if (
 /*slob_t *prev, *cur, *aligned = NULL;
@@ -495,10 +495,10 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 		}*/
 		//if (avail >= units + delta) { /* room enough? */
 		slob_t *next;
-		cur = best -> cur;
-		prev = best -> prev;
-		sp = best -> page;
-		avail = best->block_size;
+		cur = best.cur;
+		prev = best.prev;
+		sp = best.page;
+		avail = best.block_size;
 
 		if (delta) { /* need to fragment head to align? */
 			next = slob_next(cur);
@@ -536,7 +536,7 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 
 
 	/* Not enough space: must allocate a new page */
-	if (best->block_size == PAGE_SIZE + 1) {
+	if (best.block_size == PAGE_SIZE + 1) {
 		b = slob_new_pages(gfp & ~__GFP_ZERO, 0, node);
 		if (!b)
 			return NULL;
-- 
1.5.2.1


From 58efd2b7a9244de0c39eb199f5ad5318bea38975 Mon Sep 17 00:00:00 2001
From: martinm2 <martinm2@onid.orst.edu>
Date: Sun, 7 Nov 2010 18:28:58 -0800
Subject: [PATCH] Fixing more build errors (take...unknown+1)

---
 linux-2.6.34.7/mm/slob.c |    7 +++++--
 1 files changed, 5 insertions(+), 2 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index c2abae4..6f5f0fc 100755
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -474,12 +474,12 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 		//	list_move_tail(slob_list, prev->next);
 		//break;
 	}
-	spin_unlock_irqrestore(&slob_lock, flags);
+	//spin_unlock_irqrestore(&slob_lock, flags);
 
 	/* Sommit found */
 	if (best.cur != NULL) {
 		if(align) {
-			aligned = (slob_t *) ALIGN ((unsigned long)cur, align);
+			aligned = (slob_t *) ALIGN ((unsigned long)best.cur, align);
 			delta = aligned - best.cur;
 		}
 		//if (
@@ -526,6 +526,9 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 		sp->units -= size;
 		if (!sp->units)
 			clear_slob_page_free(sp);
+
+
+		spin_unlock_irqrestore(&slob_lock, flags);
 		//return cur;
 	//}
 	//if (slob_last(cur))
-- 
1.5.2.1


From 2a5abab8056a1ca553e4c9108a707e0ada4804fc Mon Sep 17 00:00:00 2001
From: martinm2 <martinm2@onid.orst.edu>
Date: Sun, 7 Nov 2010 18:46:01 -0800
Subject: [PATCH] Fixing more build errors (take...unknown+1)

---
 linux-2.6.34.7/mm/slob.c |    5 +++--
 1 files changed, 3 insertions(+), 2 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index 6f5f0fc..a39d6eb 100755
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -421,10 +421,11 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 	struct slob_page *sp;
 	struct list_head *prev;
 	struct list_head *slob_list;
-	slob_t *b = NULL;
+	slob_t *b = NULL, *cur = NULL;
 	unsigned long flags;
 	struct best_block best;
 	slobidx_t avail;
+	int delta = 0;
 	
 	//if (size < SLOB_BREAK1)
 		slob_list = &free_slob_small;
@@ -517,7 +518,7 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 				sp->free = next;
 		} else { /* fragment */
 			if (prev)
-				set_slob(prev, slob_units(prev), cur + units);
+				set_slob(prev, slob_units(prev), cur + size);
 			else
 				sp->free = cur + size;
 			set_slob(cur + size, avail - size, next);
-- 
1.5.2.1


From 09359438ddea3c3af843da885e89c8eb35e09971 Mon Sep 17 00:00:00 2001
From: martinm2 <martinm2@onid.orst.edu>
Date: Sun, 7 Nov 2010 19:26:34 -0800
Subject: [PATCH] More build error fixes

---
 linux-2.6.34.7/mm/slob.c |    6 ++++--
 1 files changed, 4 insertions(+), 2 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index a39d6eb..8fe257b 100755
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -419,7 +419,9 @@ static void *slob_page_alloc(struct slob_page *sp, size_t size, int align)
 static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 {
 	struct slob_page *sp;
-	struct list_head *prev;
+	//struct list_head *prev;
+	slob_t *prev;
+	slob_t *next;
 	struct list_head *slob_list;
 	slob_t *b = NULL, *cur = NULL;
 	unsigned long flags;
@@ -495,7 +497,7 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 			delta = aligned - cur;
 		}*/
 		//if (avail >= units + delta) { /* room enough? */
-		slob_t *next;
+		
 		cur = best.cur;
 		prev = best.prev;
 		sp = best.page;
-- 
1.5.2.1


From 48156c9ef7f172ae25c3a975784d113cd058227b Mon Sep 17 00:00:00 2001
From: martinm2 <martinm2@onid.orst.edu>
Date: Sun, 7 Nov 2010 19:34:17 -0800
Subject: [PATCH] More build error fixes

---
 linux-2.6.34.7/mm/slob.c |   12 ++++++++----
 1 files changed, 8 insertions(+), 4 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index 8fe257b..d9fff92 100755
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -101,9 +101,7 @@ struct best_block {
 	slob_page *page		/* Page with best fit */
 };
 
-/* Function prototypes for system calls */
-unsigned int sys_get_slob_amt_claimed();
-unsigned int sys_get_slob_amt_free();
+
 
 /*
  * We use struct page fields to manage some slob allocation aspects,
@@ -150,6 +148,11 @@ static LIST_HEAD(free_slob_large);
 
 static unsigned int pages_alloc = 0;
 
+
+/* Function prototypes for system calls */
+unsigned int sys_get_slob_amt_claimed();
+unsigned int sys_get_slob_amt_free();
+
 /*
  * is_slob_page: True for all slob pages (false for bigblock pages)
  */
@@ -358,7 +361,7 @@ static void find_best_fit_block(struct slob_page *sp, struct best_block *best, s
                         //return cur;
                 }
                 if (slob_last(cur))
-                        return NULL;
+                        return;
         }
 }
 
@@ -422,6 +425,7 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 	//struct list_head *prev;
 	slob_t *prev;
 	slob_t *next;
+	slob_t *aligned;
 	struct list_head *slob_list;
 	slob_t *b = NULL, *cur = NULL;
 	unsigned long flags;
-- 
1.5.2.1


From 61fd4f0b4da3527f254fe7c9dcf5031f07e3c535 Mon Sep 17 00:00:00 2001
From: martinm2 <martinm2@onid.orst.edu>
Date: Sun, 7 Nov 2010 20:12:36 -0800
Subject: [PATCH] Trying to solve the mystery of the missing members (take one)

---
 linux-2.6.34.7/mm/slob.c |    6 +++---
 1 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index d9fff92..06eb0ce 100755
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -444,9 +444,9 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 	//this could be bad
 	best.block_size = PAGE_SIZE + 1;
 	best.object_size = size;
-	best.prev = NULL;
-	best.cur = NULL;
-	best.next = NULL;
+	best->prev = NULL;
+	best->cur = NULL;
+	best->next = NULL;
 
 	spin_lock_irqsave(&slob_lock, flags);
 	/* Iterate through each partially free page, try to find room */
-- 
1.5.2.1


From 77470f7720877252947a85440f1a8fc2bd7409b1 Mon Sep 17 00:00:00 2001
From: martinm2 <martinm2@onid.orst.edu>
Date: Sun, 7 Nov 2010 20:17:06 -0800
Subject: [PATCH] Trying to solve the mystery of the missing members (take two)

---
 linux-2.6.34.7/mm/slob.c |    6 +++---
 1 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index 06eb0ce..66a9dc7 100755
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -444,9 +444,9 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 	//this could be bad
 	best.block_size = PAGE_SIZE + 1;
 	best.object_size = size;
-	best->prev = NULL;
-	best->cur = NULL;
-	best->next = NULL;
+	best.(*prev) = NULL;
+	best.*cur = NULL;
+	best.*next = NULL;
 
 	spin_lock_irqsave(&slob_lock, flags);
 	/* Iterate through each partially free page, try to find room */
-- 
1.5.2.1


From 24e5d9054143abd453f5f6282734e1fc71816793 Mon Sep 17 00:00:00 2001
From: martinm2 <martinm2@onid.orst.edu>
Date: Sun, 7 Nov 2010 20:22:19 -0800
Subject: [PATCH] Trying to solve the mystery of the missing members (take three)

---
 linux-2.6.34.7/mm/slob.c |    6 +++---
 1 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index 66a9dc7..491612b 100755
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -92,7 +92,7 @@ struct slob_block {
 typedef struct slob_block slob_t;
 
 /* Keeps track of the best-fit block */
-struct best_block {
+struct best_block_slob {
 	int object_size;	/* Size of thing we're allocating */
 	slobidx_t block_size;	/* Size of block */
 	slob_t *prev		/* Previous block */
@@ -291,7 +291,7 @@ static void slob_free_pages(void *b, int order)
 /*
  * Finds best fit block in a given slob_page sp.
 */
-static void find_best_fit_block(struct slob_page *sp, struct best_block *best, size_t size, int align)
+static void find_best_fit_block(struct slob_page *sp, struct best_block_slob *best, size_t size, int align)
 {
 	slob_t *prev, *cur, *aligned = NULL;
         int delta = 0, units = SLOB_UNITS(size);
@@ -429,7 +429,7 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 	struct list_head *slob_list;
 	slob_t *b = NULL, *cur = NULL;
 	unsigned long flags;
-	struct best_block best;
+	struct best_block_slob best;
 	slobidx_t avail;
 	int delta = 0;
 	
-- 
1.5.2.1


From ff907674120d0a50470f948571785adf578eda78 Mon Sep 17 00:00:00 2001
From: martinm2 <martinm2@onid.orst.edu>
Date: Sun, 7 Nov 2010 20:30:49 -0800
Subject: [PATCH] Trying to solve the mystery of the missing members (take four)

---
 linux-2.6.34.7/mm/slob.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index 491612b..f8ce99c 100755
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -446,7 +446,7 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 	best.object_size = size;
 	best.(*prev) = NULL;
 	best.*cur = NULL;
-	best.*next = NULL;
+	best.next = 0;
 
 	spin_lock_irqsave(&slob_lock, flags);
 	/* Iterate through each partially free page, try to find room */
-- 
1.5.2.1


From e7d0b7836d46a31b8665706d34bc5c61ae6306b8 Mon Sep 17 00:00:00 2001
From: martinm2 <martinm2@onid.orst.edu>
Date: Sun, 7 Nov 2010 20:35:27 -0800
Subject: [PATCH] Trying to solve the mystery of the missing members (take four)

---
 linux-2.6.34.7/mm/slob.c |   14 +++++++-------
 1 files changed, 7 insertions(+), 7 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index f8ce99c..aa2b4cd 100755
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -95,10 +95,10 @@ typedef struct slob_block slob_t;
 struct best_block_slob {
 	int object_size;	/* Size of thing we're allocating */
 	slobidx_t block_size;	/* Size of block */
-	slob_t *prev		/* Previous block */
-	slob_t *cur		/* Current block (the best one) */
-	slob_t *next		/* Next block */
-	slob_page *page		/* Page with best fit */
+	slob_t *prev;		/* Previous block */
+	slob_t *cur;		/* Current block (the best one) */
+	slob_t *next;		/* Next block */
+	slob_page *page;		/* Page with best fit */
 };
 
 
@@ -444,9 +444,9 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 	//this could be bad
 	best.block_size = PAGE_SIZE + 1;
 	best.object_size = size;
-	best.(*prev) = NULL;
-	best.*cur = NULL;
-	best.next = 0;
+	best.prev = NULL;
+	best.cur = NULL;
+	best.next = NULL;
 
 	spin_lock_irqsave(&slob_lock, flags);
 	/* Iterate through each partially free page, try to find room */
-- 
1.5.2.1


From 28d44a12945859963662a163ee257cbb514f6155 Mon Sep 17 00:00:00 2001
From: martinm2 <martinm2@onid.orst.edu>
Date: Sun, 7 Nov 2010 20:39:07 -0800
Subject: [PATCH] Trying to solve the mystery of the missing members (take five...or is it six?)

---
 linux-2.6.34.7/mm/slob.c |   19 +++++++++++--------
 1 files changed, 11 insertions(+), 8 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index aa2b4cd..ed8d95a 100755
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -92,14 +92,7 @@ struct slob_block {
 typedef struct slob_block slob_t;
 
 /* Keeps track of the best-fit block */
-struct best_block_slob {
-	int object_size;	/* Size of thing we're allocating */
-	slobidx_t block_size;	/* Size of block */
-	slob_t *prev;		/* Previous block */
-	slob_t *cur;		/* Current block (the best one) */
-	slob_t *next;		/* Next block */
-	slob_page *page;		/* Page with best fit */
-};
+struct best_block_slob;
 
 
 
@@ -124,6 +117,16 @@ struct slob_page {
 static inline void struct_slob_page_wrong_size(void)
 { BUILD_BUG_ON(sizeof(struct slob_page) != sizeof(struct page)); }
 
+/* Keeps track of the best-fit block */
+struct best_block_slob {
+	int object_size;	/* Size of thing we're allocating */
+	slobidx_t block_size;	/* Size of block */
+	slob_t *prev;		/* Previous block */
+	slob_t *cur;		/* Current block (the best one) */
+	slob_t *next;		/* Next block */
+	slob_page *page;		/* Page with best fit */
+};
+
 /*
  * free_slob_page: call before a slob_page is returned to the page allocator.
  */
-- 
1.5.2.1


From 4d4f6370095ee54b7a343763ffecf0b063284948 Mon Sep 17 00:00:00 2001
From: martinm2 <martinm2@onid.orst.edu>
Date: Sun, 7 Nov 2010 20:45:45 -0800
Subject: [PATCH] Trying to solve the mystery of the missing members (take...going with seven)

---
 linux-2.6.34.7/mm/slob.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index ed8d95a..3fbea10 100755
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -124,7 +124,7 @@ struct best_block_slob {
 	slob_t *prev;		/* Previous block */
 	slob_t *cur;		/* Current block (the best one) */
 	slob_t *next;		/* Next block */
-	slob_page *page;		/* Page with best fit */
+	struct slob_page *page;		/* Page with best fit */
 };
 
 /*
-- 
1.5.2.1


From 5378d86be5057a841887e0a89d1b62dc07557131 Mon Sep 17 00:00:00 2001
From: martinm2 <martinm2@onid.orst.edu>
Date: Sun, 7 Nov 2010 20:56:56 -0800
Subject: [PATCH] Trying to solve the mystery of the missing members (take eight)

---
 linux-2.6.34.7/mm/slob.c |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index 3fbea10..a4ea909 100755
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -425,7 +425,7 @@ static void *slob_page_alloc(struct slob_page *sp, size_t size, int align)
 static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 {
 	struct slob_page *sp;
-	//struct list_head *prev;
+	//struct list_head *prev_loop;
 	slob_t *prev;
 	slob_t *next;
 	slob_t *aligned;
@@ -467,7 +467,7 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 			continue;
 
 		/* Attempt to alloc */
-		prev = sp->list.prev;
+		//prev_loop = sp->list.prev;
 		//b = slob_page_alloc(sp, size, align);
 		find_best_fit_block(sp, &best, size, align);
 		if((best.block_size - best.object_size) == 0){
-- 
1.5.2.1


From 027b72dfa70d0f6c925702bf73921c30a0f4ff61 Mon Sep 17 00:00:00 2001
From: martinm2 <martinm2@onid.orst.edu>
Date: Sun, 7 Nov 2010 21:01:47 -0800
Subject: [PATCH] Trying to solve the mystery of the missing members (take nine (and final))

---
 linux-2.6.34.7/mm/slob.c |    5 +++--
 1 files changed, 3 insertions(+), 2 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index a4ea909..2df8217 100755
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -153,8 +153,8 @@ static unsigned int pages_alloc = 0;
 
 
 /* Function prototypes for system calls */
-unsigned int sys_get_slob_amt_claimed();
-unsigned int sys_get_slob_amt_free();
+/*unsigned int sys_get_slob_amt_claimed();
+unsigned int sys_get_slob_amt_free();*/
 
 /*
  * is_slob_page: True for all slob pages (false for bigblock pages)
@@ -450,6 +450,7 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 	best.prev = NULL;
 	best.cur = NULL;
 	best.next = NULL;
+	best.page = NULL;
 
 	spin_lock_irqsave(&slob_lock, flags);
 	/* Iterate through each partially free page, try to find room */
-- 
1.5.2.1


From 3da138432b37b8cc7446f01e30c41b8887e3e65b Mon Sep 17 00:00:00 2001
From: CrawfordI <crawfoia@onid.orst.edu>
Date: Mon, 8 Nov 2010 16:05:04 -0800
Subject: [PATCH] Attempting to fix boot problem.

---
 linux-2.6.34.7/mm/slob.c |    9 ++++-----
 1 files changed, 4 insertions(+), 5 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index 2df8217..7920fba 100755
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -545,12 +545,8 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 	//if (slob_last(cur))
 		//return NULL;
 	}
-			
-		
-
-
+	else{		
 	/* Not enough space: must allocate a new page */
-	if (best.block_size == PAGE_SIZE + 1) {
 		b = slob_new_pages(gfp & ~__GFP_ZERO, 0, node);
 		if (!b)
 			return NULL;
@@ -570,6 +566,9 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 		/* Increment number of pages allocated. */
 		//pages_alloc++;
 	}
+
+	
+
 	if (unlikely((gfp & __GFP_ZERO) && b))
 		memset(b, 0, size);
 	return b;
-- 
1.5.2.1


From 8fd97f6820e4a7c3062818db64b7db4da4ac0920 Mon Sep 17 00:00:00 2001
From: martinm2 <martinm2@onid.orst.edu>
Date: Mon, 8 Nov 2010 16:10:53 -0800
Subject: [PATCH] Added debug printks

---
 linux-2.6.34.7/mm/slob.c |    3 +++
 1 files changed, 3 insertions(+), 0 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index 2df8217..5eeae11 100755
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -435,6 +435,7 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 	struct best_block_slob best;
 	slobidx_t avail;
 	int delta = 0;
+	printk( KERN_ALERT "Enter slob_alloc\n" );
 	
 	//if (size < SLOB_BREAK1)
 		slob_list = &free_slob_small;
@@ -488,7 +489,9 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 	//spin_unlock_irqrestore(&slob_lock, flags);
 
 	/* Sommit found */
+
 	if (best.cur != NULL) {
+		printk( KERN_ALERT "best.cur found!\n" );
 		if(align) {
 			aligned = (slob_t *) ALIGN ((unsigned long)best.cur, align);
 			delta = aligned - best.cur;
-- 
1.5.2.1


From b0813bc072f0b39a1d860d48b6c7a99972b1d590 Mon Sep 17 00:00:00 2001
From: martinm2 <martinm2@onid.orst.edu>
Date: Mon, 8 Nov 2010 16:15:38 -0800
Subject: [PATCH] Gave the debug printks meaning in life

---
 linux-2.6.34.7/mm/slob.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index 570b45b..55decee 100755
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -435,7 +435,7 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 	struct best_block_slob best;
 	slobidx_t avail;
 	int delta = 0;
-	printk( KERN_ALERT "Enter slob_alloc\n" );
+	printk( KERN_ALERT "Enter slob_alloc, size: %lu\n", size );
 	
 	//if (size < SLOB_BREAK1)
 		slob_list = &free_slob_small;
-- 
1.5.2.1


From fbd92bc2cccda7920ea56ad8d7e7a6bce2e01086 Mon Sep 17 00:00:00 2001
From: CrawfordI <crawfoia@onid.orst.edu>
Date: Mon, 8 Nov 2010 16:40:22 -0800
Subject: [PATCH] Attempting to fix boot problem pII

---
 linux-2.6.34.7/mm/slob.c |   14 +++++++-------
 1 files changed, 7 insertions(+), 7 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index 55decee..a281552 100755
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -165,7 +165,7 @@ static inline int is_slob_page(struct slob_page *sp)
 }
 
 static inline void set_slob_page(struct slob_page *sp)
-{
+:{
 	__SetPageSlab((struct page *)sp);
 }
 
@@ -312,20 +312,20 @@ static void find_best_fit_block(struct slob_page *sp, struct best_block_slob *be
 
 
                         if (delta) { // need to fragment head to align?
-                                /*next = slob_next(cur);
+                                next = slob_next(cur);/*
                                 set_slob(aligned, avail - delta, next);
-                                set_slob(cur, delta, aligned);
+                                set_slob(cur, delta, aligned);*/
                                 prev = cur;
                                 cur = aligned;
-                                avail = slob_units(cur);*/
-				if((avail - units) < (best->block_size - best->object_size)) {
+                                avail = slob_units(cur);
+				/*if((avail - units) < (best->block_size - best->object_size)) {
 					best->prev = prev;
 					best->cur = cur;
 					best->next = next;
 					best->object_size = units;
 					best->block_size = avail;
 					best->page = sp;
-				}
+				}*/
 				
                         }
 
@@ -447,7 +447,7 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 	
 	//this could be bad
 	best.block_size = PAGE_SIZE + 1;
-	best.object_size = size;
+	best.object_size = SLOB_UNITS(size);
 	best.prev = NULL;
 	best.cur = NULL;
 	best.next = NULL;
-- 
1.5.2.1


From 2d253c8a5cc5ddd537cab15e4d30716769927df8 Mon Sep 17 00:00:00 2001
From: CrawfordI <crawfoia@onid.orst.edu>
Date: Mon, 8 Nov 2010 16:58:39 -0800
Subject: [PATCH] Fixing context error

---
 linux-2.6.34.7/mm/slob.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index a281552..26d1035 100755
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -165,7 +165,7 @@ static inline int is_slob_page(struct slob_page *sp)
 }
 
 static inline void set_slob_page(struct slob_page *sp)
-:{
+{
 	__SetPageSlab((struct page *)sp);
 }
 
-- 
1.5.2.1


From 43f9b6a9d81401e373794ed53f3831cc01cb3319 Mon Sep 17 00:00:00 2001
From: martinm2 <martinm2@onid.orst.edu>
Date: Mon, 8 Nov 2010 17:10:38 -0800
Subject: [PATCH] Removed optimization parts of our code in case they are breaking it

---
 linux-2.6.34.7/mm/slob.c |   32 +++++++++++++++++++++-----------
 1 files changed, 21 insertions(+), 11 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index 26d1035..9be08e3 100755
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -472,9 +472,13 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 		//prev_loop = sp->list.prev;
 		//b = slob_page_alloc(sp, size, align);
 		find_best_fit_block(sp, &best, size, align);
-		if((best.block_size - best.object_size) == 0){
+
+
+		/*if((best.block_size - best.object_size) == 0){
 			break;
-		}
+		}*/
+
+
 		//if (!b)
 		//	continue;
 
@@ -488,13 +492,19 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 	}
 	//spin_unlock_irqrestore(&slob_lock, flags);
 
-	/* Sommit found */
 
+	/* Sommit found */
 	if (best.cur != NULL) {
 		printk( KERN_ALERT "best.cur found!\n" );
+
+		cur = best.cur;
+		prev = best.prev;
+		sp = best.page;
+		avail = best.block_size;
+
 		if(align) {
-			aligned = (slob_t *) ALIGN ((unsigned long)best.cur, align);
-			delta = aligned - best.cur;
+			aligned = (slob_t *) ALIGN ((unsigned long)cur, align);
+			delta = aligned - cur;
 		}
 		//if (
 /*slob_t *prev, *cur, *aligned = NULL;
@@ -509,10 +519,7 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 		}*/
 		//if (avail >= units + delta) { /* room enough? */
 		
-		cur = best.cur;
-		prev = best.prev;
-		sp = best.page;
-		avail = best.block_size;
+		
 
 		if (delta) { /* need to fragment head to align? */
 			next = slob_next(cur);
@@ -542,13 +549,16 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 			clear_slob_page_free(sp);
 
 
-		spin_unlock_irqrestore(&slob_lock, flags);
+		
 		//return cur;
 	//}
 	//if (slob_last(cur))
 		//return NULL;
 	}
-	else{		
+
+	spin_unlock_irqrestore(&slob_lock, flags);
+
+	if( best.cur == NULL ) {		
 	/* Not enough space: must allocate a new page */
 		b = slob_new_pages(gfp & ~__GFP_ZERO, 0, node);
 		if (!b)
-- 
1.5.2.1


From 9605a4061c4508e02af7708a87beb2342f8873b7 Mon Sep 17 00:00:00 2001
From: martinm2 <martinm2@onid.orst.edu>
Date: Mon, 8 Nov 2010 17:29:46 -0800
Subject: [PATCH] Changed a return in a void to a break

---
 linux-2.6.34.7/mm/slob.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index 9be08e3..6222bb3 100755
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -364,7 +364,7 @@ static void find_best_fit_block(struct slob_page *sp, struct best_block_slob *be
                         //return cur;
                 }
                 if (slob_last(cur))
-                        return;
+                        break;
         }
 }
 
-- 
1.5.2.1


From 6e8940fb15dabda37f57598ebba29d03571813c8 Mon Sep 17 00:00:00 2001
From: CrawfordI <crawfoia@onid.orst.edu>
Date: Mon, 8 Nov 2010 17:35:05 -0800
Subject: [PATCH] Attempting to fix boot problem pIII

---
 linux-2.6.34.7/mm/slob.c |   12 ++++++------
 1 files changed, 6 insertions(+), 6 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index 9be08e3..fe24eba 100755
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -531,25 +531,25 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 		}
 
 		next = slob_next(cur);
-		if (avail == size) { /* exact fit? unlink. */
+		if (avail == SLOB_UNITS(size)) { /* exact fit? unlink. */
 			if (prev)
 				set_slob(prev, slob_units(prev), next);
 			else
 				sp->free = next;
 		} else { /* fragment */
 			if (prev)
-				set_slob(prev, slob_units(prev), cur + size);
+				set_slob(prev, slob_units(prev), cur + SLOB_UNITS(size));
 			else
-				sp->free = cur + size;
-			set_slob(cur + size, avail - size, next);
+				sp->free = cur + SLOB_UNITS(size);
+			set_slob(cur + size, avail - SLOB_UNITS(size), next);
 		}
 
-		sp->units -= size;
+		sp->units -= SLOB_UNITS(size);
 		if (!sp->units)
 			clear_slob_page_free(sp);
 
 
-		
+		b = cur;
 		//return cur;
 	//}
 	//if (slob_last(cur))
-- 
1.5.2.1


From ee29679900eae1a3b33d2300ec85c0d65ace44fe Mon Sep 17 00:00:00 2001
From: martinm2 <martinm2@onid.orst.edu>
Date: Mon, 8 Nov 2010 17:42:45 -0800
Subject: [PATCH] OMFG IT WORKS YAYA added more debug printk

---
 linux-2.6.34.7/mm/slob.c |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index 0358597..779635e 100755
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -560,6 +560,7 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 
 	if( best.cur == NULL ) {		
 	/* Not enough space: must allocate a new page */
+		printk( KERN_ALERT "Require moar sandvich!\n" );
 		b = slob_new_pages(gfp & ~__GFP_ZERO, 0, node);
 		if (!b)
 			return NULL;
-- 
1.5.2.1


From 18d0205c05425114176c0d6a9219911db038ef6d Mon Sep 17 00:00:00 2001
From: martinm2 <martinm2@onid.orst.edu>
Date: Mon, 8 Nov 2010 17:52:53 -0800
Subject: [PATCH] OMFG IT WORKS YAYA added more debug printk

---
 linux-2.6.34.7/mm/slob.c |    4 ++++
 1 files changed, 4 insertions(+), 0 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index 779635e..c818014 100755
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -503,6 +503,7 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 		avail = best.block_size;
 
 		if(align) {
+			printk( KERN_ALERT "Require alignment.\n" );
 			aligned = (slob_t *) ALIGN ((unsigned long)cur, align);
 			delta = aligned - cur;
 		}
@@ -522,6 +523,7 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 		
 
 		if (delta) { /* need to fragment head to align? */
+			printk( KERN_ALERT "Fragment w/ delta: %d\n", delta );
 			next = slob_next(cur);
 			set_slob(aligned, avail - delta, next);
 			set_slob(cur, delta, aligned);
@@ -532,11 +534,13 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 
 		next = slob_next(cur);
 		if (avail == SLOB_UNITS(size)) { /* exact fit? unlink. */
+			printk( KERN_ALERT "Exact fit.\n" );
 			if (prev)
 				set_slob(prev, slob_units(prev), next);
 			else
 				sp->free = next;
 		} else { /* fragment */
+			printk( KERN_ALERT "Not exact fit.\n" );
 			if (prev)
 				set_slob(prev, slob_units(prev), cur + SLOB_UNITS(size));
 			else
-- 
1.5.2.1


From b7adaa2ab2f4b116a5b391c2a0d1564b1c0bd458 Mon Sep 17 00:00:00 2001
From: martinm2 <martinm2@onid.orst.edu>
Date: Mon, 8 Nov 2010 17:59:10 -0800
Subject: [PATCH] Added printks to find_best_fit()

---
 linux-2.6.34.7/mm/slob.c |    8 ++++++--
 1 files changed, 6 insertions(+), 2 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index c818014..e03d0af 100755
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -333,6 +333,7 @@ static void find_best_fit_block(struct slob_page *sp, struct best_block_slob *be
                         next = slob_next(cur);
                         if (avail == units) { /* exact fit? unlink. */
                                 //if (prev)
+					printk( KERN_ALERT "Best fit is exact!\n" );
 					best->prev = prev;
 					best->cur = cur;
 					best->next = next;
@@ -349,6 +350,7 @@ static void find_best_fit_block(struct slob_page *sp, struct best_block_slob *be
                                 //       sp->free = cur + units;
                                 //set_slob(cur + units, avail - units, next);
 				if ((avail - units) < (best->block_size - best->object_size)) {
+					printk( KERN_ALERT "Best fit is not exact...\n" );
 					best->prev = prev;
                                         best->cur = cur;
                                         best->next = next;
@@ -363,8 +365,10 @@ static void find_best_fit_block(struct slob_page *sp, struct best_block_slob *be
                         //        clear_slob_page_free(sp);
                         //return cur;
                 }
-                if (slob_last(cur))
+                if (slob_last(cur)) {
+			printk( KERN_ALERT "Hit end of block.\n" );
                         break;
+		}
         }
 }
 
@@ -505,7 +509,7 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 		if(align) {
 			printk( KERN_ALERT "Require alignment.\n" );
 			aligned = (slob_t *) ALIGN ((unsigned long)cur, align);
-			delta = aligned - cur;
+			delta = aligned - cur;printk( KERN_ALERT "Require alignment.\n" );
 		}
 		//if (
 /*slob_t *prev, *cur, *aligned = NULL;
-- 
1.5.2.1


From 77bef86696a051d0b2810d19c991e323e026865b Mon Sep 17 00:00:00 2001
From: martinm2 <martinm2@onid.orst.edu>
Date: Mon, 8 Nov 2010 18:05:26 -0800
Subject: [PATCH] printks are fun

---
 linux-2.6.34.7/mm/slob.c |    4 ++++
 1 files changed, 4 insertions(+), 0 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index e03d0af..25b1a88 100755
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -421,6 +421,7 @@ static void *slob_page_alloc(struct slob_page *sp, size_t size, int align)
 		if (slob_last(cur))
 			return NULL;
 	}
+	printk( KERN_ALERT "Exited inner page lOOOOOOOp.\n" );
 }
 
 /*
@@ -494,6 +495,9 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 		//	list_move_tail(slob_list, prev->next);
 		//break;
 	}
+
+	printk( KERN_ALERT "Exited for lolololoop.\n" );
+
 	//spin_unlock_irqrestore(&slob_lock, flags);
 
 
-- 
1.5.2.1


From c2e55d5732d6f35a4fda895eb06e979cb2a2d503 Mon Sep 17 00:00:00 2001
From: martinm2 <martinm2@onid.orst.edu>
Date: Mon, 8 Nov 2010 18:11:06 -0800
Subject: [PATCH] printks are fun

---
 linux-2.6.34.7/mm/slob.c |    3 ++-
 1 files changed, 2 insertions(+), 1 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index 25b1a88..e42dfaa 100755
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -370,6 +370,7 @@ static void find_best_fit_block(struct slob_page *sp, struct best_block_slob *be
                         break;
 		}
         }
+	printk( KERN_ALERT "Exited inner page lOOOOOOOp.\n" );
 }
 
 /*
@@ -421,7 +422,7 @@ static void *slob_page_alloc(struct slob_page *sp, size_t size, int align)
 		if (slob_last(cur))
 			return NULL;
 	}
-	printk( KERN_ALERT "Exited inner page lOOOOOOOp.\n" );
+	
 }
 
 /*
-- 
1.5.2.1


From 59834b60ce83ba8b6027e79926ac93788db54d03 Mon Sep 17 00:00:00 2001
From: martinm2 <martinm2@onid.orst.edu>
Date: Mon, 8 Nov 2010 18:24:16 -0800
Subject: [PATCH] printks are fun, in find_best_fit()

---
 linux-2.6.34.7/mm/slob.c |   15 ++++++++-------
 1 files changed, 8 insertions(+), 7 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index e42dfaa..62f1a92 100755
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -312,10 +312,11 @@ static void find_best_fit_block(struct slob_page *sp, struct best_block_slob *be
 
 
                         if (delta) { // need to fragment head to align?
-                                next = slob_next(cur);/*
+				printk( KERN_ALERT "Best fit has alignment: " );
+                                /*next = slob_next(cur);/*
                                 set_slob(aligned, avail - delta, next);
                                 set_slob(cur, delta, aligned);*/
-                                prev = cur;
+                                /*prev = cur;
                                 cur = aligned;
                                 avail = slob_units(cur);
 				/*if((avail - units) < (best->block_size - best->object_size)) {
@@ -331,7 +332,7 @@ static void find_best_fit_block(struct slob_page *sp, struct best_block_slob *be
 
 
                         next = slob_next(cur);
-                        if (avail == units) { /* exact fit? unlink. */
+                        if (avail == units + delta ) { /* exact fit? unlink. */
                                 //if (prev)
 					printk( KERN_ALERT "Best fit is exact!\n" );
 					best->prev = prev;
@@ -366,7 +367,7 @@ static void find_best_fit_block(struct slob_page *sp, struct best_block_slob *be
                         //return cur;
                 }
                 if (slob_last(cur)) {
-			printk( KERN_ALERT "Hit end of block.\n" );
+			//printk( KERN_ALERT "Hit end of block.\n" );
                         break;
 		}
         }
@@ -514,7 +515,7 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 		if(align) {
 			printk( KERN_ALERT "Require alignment.\n" );
 			aligned = (slob_t *) ALIGN ((unsigned long)cur, align);
-			delta = aligned - cur;printk( KERN_ALERT "Require alignment.\n" );
+			delta = aligned - cur;
 		}
 		//if (
 /*slob_t *prev, *cur, *aligned = NULL;
@@ -543,13 +544,13 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 
 		next = slob_next(cur);
 		if (avail == SLOB_UNITS(size)) { /* exact fit? unlink. */
-			printk( KERN_ALERT "Exact fit.\n" );
+			printk( KERN_ALERT "ALLOC Exact fit.\n" );
 			if (prev)
 				set_slob(prev, slob_units(prev), next);
 			else
 				sp->free = next;
 		} else { /* fragment */
-			printk( KERN_ALERT "Not exact fit.\n" );
+			printk( KERN_ALERT "ALLOC Not exact fit.\n" );
 			if (prev)
 				set_slob(prev, slob_units(prev), cur + SLOB_UNITS(size));
 			else
-- 
1.5.2.1


From 02f1e56bc918674098e95fd771e59e3e16f4ed57 Mon Sep 17 00:00:00 2001
From: martinm2 <martinm2@onid.orst.edu>
Date: Mon, 8 Nov 2010 18:29:30 -0800
Subject: [PATCH] added debug counter to looping through blocks

---
 linux-2.6.34.7/mm/slob.c |    3 +++
 1 files changed, 3 insertions(+), 0 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index 62f1a92..ec820ca 100755
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -298,8 +298,11 @@ static void find_best_fit_block(struct slob_page *sp, struct best_block_slob *be
 {
 	slob_t *prev, *cur, *aligned = NULL;
         int delta = 0, units = SLOB_UNITS(size);
+	int i = 0;
 
         for (prev = NULL, cur = sp->free; ; prev = cur, cur = slob_next(cur)) {
+	printk( KERN_ALERT "i=%d\t", i );
+	i++;
         slobidx_t avail = slob_units(cur);
 
                 if (align) {
-- 
1.5.2.1


From 64e79c743fabed7a542301e737098e41bd3650d3 Mon Sep 17 00:00:00 2001
From: martinm2 <martinm2@onid.orst.edu>
Date: Mon, 8 Nov 2010 18:39:25 -0800
Subject: [PATCH] Possible bug fix

---
 linux-2.6.34.7/mm/slob.c |   14 +++++++++-----
 1 files changed, 9 insertions(+), 5 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index ec820ca..025c508 100755
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -301,8 +301,12 @@ static void find_best_fit_block(struct slob_page *sp, struct best_block_slob *be
 	int i = 0;
 
         for (prev = NULL, cur = sp->free; ; prev = cur, cur = slob_next(cur)) {
-	printk( KERN_ALERT "i=%d\t", i );
+	printk( KERN_ALERT "i=%d   ", i );
 	i++;
+	if ( best->cur == cur ) {
+		printk( KERN_ALERT "Loop around failure   " );
+                break;
+	}
         slobidx_t avail = slob_units(cur);
 
                 if (align) {
@@ -353,7 +357,7 @@ static void find_best_fit_block(struct slob_page *sp, struct best_block_slob *be
                                 //else
                                 //       sp->free = cur + units;
                                 //set_slob(cur + units, avail - units, next);
-				if ((avail - units) < (best->block_size - best->object_size)) {
+				if ((avail - ( units + delta ) ) < (best->block_size - best->object_size)) {
 					printk( KERN_ALERT "Best fit is not exact...\n" );
 					best->prev = prev;
                                         best->cur = cur;
@@ -369,12 +373,12 @@ static void find_best_fit_block(struct slob_page *sp, struct best_block_slob *be
                         //        clear_slob_page_free(sp);
                         //return cur;
                 }
-                if (slob_last(cur)) {
-			//printk( KERN_ALERT "Hit end of block.\n" );
+                if ( slob_last(cur) ) {
+			printk( KERN_ALERT "Hit end of block     " );
                         break;
 		}
         }
-	printk( KERN_ALERT "Exited inner page lOOOOOOOp.\n" );
+	printk( KERN_ALERT "and out of block.\n" );
 }
 
 /*
-- 
1.5.2.1


From c7212c94746d896a8c4c1dfc22fe93496c06ad20 Mon Sep 17 00:00:00 2001
From: martinm2 <martinm2@onid.orst.edu>
Date: Mon, 8 Nov 2010 18:48:23 -0800
Subject: [PATCH] Infinite loop bug searching

---
 linux-2.6.34.7/mm/slob.c |   15 ++++++++-------
 1 files changed, 8 insertions(+), 7 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index 025c508..583b9df 100755
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -301,12 +301,12 @@ static void find_best_fit_block(struct slob_page *sp, struct best_block_slob *be
 	int i = 0;
 
         for (prev = NULL, cur = sp->free; ; prev = cur, cur = slob_next(cur)) {
-	printk( KERN_ALERT "i=%d   ", i );
+	//printk( KERN_ALERT "i=%d   ", i );
 	i++;
-	if ( best->cur == cur ) {
+	/*if ( best->cur == cur ) {
 		printk( KERN_ALERT "Loop around failure   " );
                 break;
-	}
+	}*/
         slobidx_t avail = slob_units(cur);
 
                 if (align) {
@@ -320,13 +320,13 @@ static void find_best_fit_block(struct slob_page *sp, struct best_block_slob *be
 
                         if (delta) { // need to fragment head to align?
 				printk( KERN_ALERT "Best fit has alignment: " );
-                                /*next = slob_next(cur);/*
+                                /*next = slob_next(cur);
                                 set_slob(aligned, avail - delta, next);
-                                set_slob(cur, delta, aligned);*/
-                                /*prev = cur;
+                                set_slob(cur, delta, aligned);
+                                prev = cur;
                                 cur = aligned;
                                 avail = slob_units(cur);
-				/*if((avail - units) < (best->block_size - best->object_size)) {
+				if((avail - units) < (best->block_size - best->object_size)) {
 					best->prev = prev;
 					best->cur = cur;
 					best->next = next;
@@ -373,6 +373,7 @@ static void find_best_fit_block(struct slob_page *sp, struct best_block_slob *be
                         //        clear_slob_page_free(sp);
                         //return cur;
                 }
+		printf( "slob_last(cur) == %d\n", slob_last(cur) );
                 if ( slob_last(cur) ) {
 			printk( KERN_ALERT "Hit end of block     " );
                         break;
-- 
1.5.2.1


From dfd1fe16928e6e0b5fec8e7d5ac7085cc965a78e Mon Sep 17 00:00:00 2001
From: martinm2 <martinm2@onid.orst.edu>
Date: Mon, 8 Nov 2010 18:50:39 -0800
Subject: [PATCH] Infinite loop bug searching

---
 linux-2.6.34.7/mm/slob.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index 583b9df..444397a 100755
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -373,7 +373,7 @@ static void find_best_fit_block(struct slob_page *sp, struct best_block_slob *be
                         //        clear_slob_page_free(sp);
                         //return cur;
                 }
-		printf( "slob_last(cur) == %d\n", slob_last(cur) );
+		printk( "slob_last(cur) == %d\n", slob_last(cur) );
                 if ( slob_last(cur) ) {
 			printk( KERN_ALERT "Hit end of block     " );
                         break;
-- 
1.5.2.1


From eba44da08df970883d99d21b463a4d6548638817 Mon Sep 17 00:00:00 2001
From: martinm2 <martinm2@onid.orst.edu>
Date: Mon, 8 Nov 2010 19:00:51 -0800
Subject: [PATCH] Infinite loop bug searching

---
 linux-2.6.34.7/mm/slob.c |    5 +++--
 1 files changed, 3 insertions(+), 2 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index 444397a..4479d13 100755
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -351,7 +351,8 @@ static void find_best_fit_block(struct slob_page *sp, struct best_block_slob *be
                                 	// set_slob(prev, slob_units(prev), next);
                                 //else
                                   //      sp->free = next;
-                        } else { /* fragment */
+                        }
+			else { /* fragment */
                                 //if (prev)
                                   //      set_slob(prev, slob_units(prev), cur + units);
                                 //else
@@ -373,7 +374,7 @@ static void find_best_fit_block(struct slob_page *sp, struct best_block_slob *be
                         //        clear_slob_page_free(sp);
                         //return cur;
                 }
-		printk( "slob_last(cur) == %d\n", slob_last(cur) );
+		//printk( "slob_last(cur) == %d\n", slob_last(cur) );
                 if ( slob_last(cur) ) {
 			printk( KERN_ALERT "Hit end of block     " );
                         break;
-- 
1.5.2.1


From b52b291808599c1ced76336b93856e1898b0f675 Mon Sep 17 00:00:00 2001
From: martinm2 <martinm2@onid.orst.edu>
Date: Mon, 8 Nov 2010 19:04:43 -0800
Subject: [PATCH] Infinite loop bug searching

---
 linux-2.6.34.7/mm/slob.c |   10 +++++-----
 1 files changed, 5 insertions(+), 5 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index 4479d13..5095b49 100755
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -319,7 +319,7 @@ static void find_best_fit_block(struct slob_page *sp, struct best_block_slob *be
 
 
                         if (delta) { // need to fragment head to align?
-				printk( KERN_ALERT "Best fit has alignment: " );
+				//printk( KERN_ALERT "Best fit has alignment: " );
                                 /*next = slob_next(cur);
                                 set_slob(aligned, avail - delta, next);
                                 set_slob(cur, delta, aligned);
@@ -341,7 +341,7 @@ static void find_best_fit_block(struct slob_page *sp, struct best_block_slob *be
                         next = slob_next(cur);
                         if (avail == units + delta ) { /* exact fit? unlink. */
                                 //if (prev)
-					printk( KERN_ALERT "Best fit is exact!\n" );
+					//printk( KERN_ALERT "Best fit is exact!\n" );
 					best->prev = prev;
 					best->cur = cur;
 					best->next = next;
@@ -359,7 +359,7 @@ static void find_best_fit_block(struct slob_page *sp, struct best_block_slob *be
                                 //       sp->free = cur + units;
                                 //set_slob(cur + units, avail - units, next);
 				if ((avail - ( units + delta ) ) < (best->block_size - best->object_size)) {
-					printk( KERN_ALERT "Best fit is not exact...\n" );
+					//printk( KERN_ALERT "Best fit is not exact...\n" );
 					best->prev = prev;
                                         best->cur = cur;
                                         best->next = next;
@@ -376,11 +376,11 @@ static void find_best_fit_block(struct slob_page *sp, struct best_block_slob *be
                 }
 		//printk( "slob_last(cur) == %d\n", slob_last(cur) );
                 if ( slob_last(cur) ) {
-			printk( KERN_ALERT "Hit end of block     " );
+			//printk( KERN_ALERT "Hit end of block     " );
                         break;
 		}
         }
-	printk( KERN_ALERT "and out of block.\n" );
+	//printk( KERN_ALERT "and out of block.\n" );
 }
 
 /*
-- 
1.5.2.1


From 974ae069dd46eba1239575c3efe8025428a507d2 Mon Sep 17 00:00:00 2001
From: martinm2 <martinm2@onid.orst.edu>
Date: Mon, 8 Nov 2010 19:16:26 -0800
Subject: [PATCH] Infinite loop bug searching

---
 linux-2.6.34.7/mm/slob.c |    8 +++++---
 1 files changed, 5 insertions(+), 3 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index 5095b49..63d5839 100755
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -450,7 +450,7 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 	unsigned long flags;
 	struct best_block_slob best;
 	slobidx_t avail;
-	int delta = 0;
+	int delta = 0, numPages = 0, iterPage = 0;
 	printk( KERN_ALERT "Enter slob_alloc, size: %lu\n", size );
 	
 	//if (size < SLOB_BREAK1)
@@ -477,6 +477,7 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 		 * If there's a node specification, search for a partial
 		 * page with a matching node id in the freelist.
 		 */
+iterPage++;
 		if (node != -1 && page_to_nid(&sp->page) != node)
 			continue;
 #endif
@@ -507,7 +508,7 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 		//break;
 	}
 
-	printk( KERN_ALERT "Exited for lolololoop.\n" );
+	printk( KERN_ALERT "Exited for lolololoop. iterPage: %d\n", iterPage );
 
 	//spin_unlock_irqrestore(&slob_lock, flags);
 
@@ -583,7 +584,8 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 
 	if( best.cur == NULL ) {		
 	/* Not enough space: must allocate a new page */
-		printk( KERN_ALERT "Require moar sandvich!\n" );
+		numPages++;
+		printk( KERN_ALERT "Require moar sandvich! %d\n", numPages );
 		b = slob_new_pages(gfp & ~__GFP_ZERO, 0, node);
 		if (!b)
 			return NULL;
-- 
1.5.2.1


From b17ea19284b33e5c2eff0b403f236920409b46c6 Mon Sep 17 00:00:00 2001
From: martinm2 <martinm2@onid.orst.edu>
Date: Mon, 8 Nov 2010 19:22:13 -0800
Subject: [PATCH] Infinite loop bug searching

---
 linux-2.6.34.7/mm/slob.c |    3 ++-
 1 files changed, 2 insertions(+), 1 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index 63d5839..46b3ed9 100755
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -477,11 +477,12 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 		 * If there's a node specification, search for a partial
 		 * page with a matching node id in the freelist.
 		 */
-iterPage++;
+		
 		if (node != -1 && page_to_nid(&sp->page) != node)
 			continue;
 #endif
 		/* Enough room on this page? */
+		iterPage++;
 		if (sp->units < SLOB_UNITS(size))
 			continue;
 
-- 
1.5.2.1


From ed7c4c336c7e1507e3922a0cf7e63c459306adfe Mon Sep 17 00:00:00 2001
From: martinm2 <martinm2@onid.orst.edu>
Date: Mon, 8 Nov 2010 19:29:40 -0800
Subject: [PATCH] Infinite loop bug searching

---
 linux-2.6.34.7/mm/slob.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index 46b3ed9..cf7a698 100755
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -452,6 +452,7 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 	slobidx_t avail;
 	int delta = 0, numPages = 0, iterPage = 0;
 	printk( KERN_ALERT "Enter slob_alloc, size: %lu\n", size );
+	printk( KERN_ALERT "Require alignment: %d.\n", align );
 	
 	//if (size < SLOB_BREAK1)
 		slob_list = &free_slob_small;
@@ -524,7 +525,6 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 		avail = best.block_size;
 
 		if(align) {
-			printk( KERN_ALERT "Require alignment.\n" );
 			aligned = (slob_t *) ALIGN ((unsigned long)cur, align);
 			delta = aligned - cur;
 		}
-- 
1.5.2.1


From 1089fcdb28731e01a140201293254c10f710ab34 Mon Sep 17 00:00:00 2001
From: martinm2 <martinm2@onid.orst.edu>
Date: Mon, 8 Nov 2010 19:41:03 -0800
Subject: [PATCH] Infinite loop bug searching

---
 linux-2.6.34.7/mm/slob.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index cf7a698..34017f0 100755
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -374,7 +374,7 @@ static void find_best_fit_block(struct slob_page *sp, struct best_block_slob *be
                         //        clear_slob_page_free(sp);
                         //return cur;
                 }
-		//printk( "slob_last(cur) == %d\n", slob_last(cur) );
+		printk( "slob_last(cur) == %d, sp: %lu, cur: %lu\n", slob_last(cur), (unsigned long)sp, (unsigned long)cur );
                 if ( slob_last(cur) ) {
 			//printk( KERN_ALERT "Hit end of block     " );
                         break;
-- 
1.5.2.1


From c05a3a2c863328210ff9515936a2f4ea7f813c6d Mon Sep 17 00:00:00 2001
From: martinm2 <martinm2@onid.orst.edu>
Date: Mon, 8 Nov 2010 19:58:26 -0800
Subject: [PATCH] Infinite loop bug searching

---
 linux-2.6.34.7/mm/slob.c |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index 34017f0..436c5e4 100755
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -374,7 +374,7 @@ static void find_best_fit_block(struct slob_page *sp, struct best_block_slob *be
                         //        clear_slob_page_free(sp);
                         //return cur;
                 }
-		printk( "slob_last(cur) == %d, sp: %lu, cur: %lu\n", slob_last(cur), (unsigned long)sp, (unsigned long)cur );
+		//printk( "slob_last(cur) == %d, sp: %lu, cur: %lu\n", slob_last(cur), (unsigned long)sp, (unsigned long)cur );
                 if ( slob_last(cur) ) {
 			//printk( KERN_ALERT "Hit end of block     " );
                         break;
@@ -566,7 +566,7 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 				set_slob(prev, slob_units(prev), cur + SLOB_UNITS(size));
 			else
 				sp->free = cur + SLOB_UNITS(size);
-			set_slob(cur + size, avail - SLOB_UNITS(size), next);
+			set_slob(cur + SLOB_UNITS(size), avail - SLOB_UNITS(size), next);
 		}
 
 		sp->units -= SLOB_UNITS(size);
-- 
1.5.2.1


From 5ecb70a430e97fd9e855039966d6968a5fc7e6bf Mon Sep 17 00:00:00 2001
From: martinm2 <martinm2@onid.orst.edu>
Date: Mon, 8 Nov 2010 20:39:50 -0800
Subject: [PATCH] Infinite loop bug maybe fixed, removed printks for time

---
 linux-2.6.34.7/mm/slob.c |   16 ++++++++--------
 1 files changed, 8 insertions(+), 8 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index 436c5e4..484cc26 100755
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -451,8 +451,8 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 	struct best_block_slob best;
 	slobidx_t avail;
 	int delta = 0, numPages = 0, iterPage = 0;
-	printk( KERN_ALERT "Enter slob_alloc, size: %lu\n", size );
-	printk( KERN_ALERT "Require alignment: %d.\n", align );
+	//printk( KERN_ALERT "Enter slob_alloc, size: %lu\n", size );
+	//printk( KERN_ALERT "Require alignment: %d.\n", align );
 	
 	//if (size < SLOB_BREAK1)
 		slob_list = &free_slob_small;
@@ -510,14 +510,14 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 		//break;
 	}
 
-	printk( KERN_ALERT "Exited for lolololoop. iterPage: %d\n", iterPage );
+	//printk( KERN_ALERT "Exited for lolololoop. iterPage: %d\n", iterPage );
 
 	//spin_unlock_irqrestore(&slob_lock, flags);
 
 
 	/* Sommit found */
 	if (best.cur != NULL) {
-		printk( KERN_ALERT "best.cur found!\n" );
+		//printk( KERN_ALERT "best.cur found!\n" );
 
 		cur = best.cur;
 		prev = best.prev;
@@ -544,7 +544,7 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 		
 
 		if (delta) { /* need to fragment head to align? */
-			printk( KERN_ALERT "Fragment w/ delta: %d\n", delta );
+			//printk( KERN_ALERT "Fragment w/ delta: %d\n", delta );
 			next = slob_next(cur);
 			set_slob(aligned, avail - delta, next);
 			set_slob(cur, delta, aligned);
@@ -555,13 +555,13 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 
 		next = slob_next(cur);
 		if (avail == SLOB_UNITS(size)) { /* exact fit? unlink. */
-			printk( KERN_ALERT "ALLOC Exact fit.\n" );
+			//printk( KERN_ALERT "ALLOC Exact fit.\n" );
 			if (prev)
 				set_slob(prev, slob_units(prev), next);
 			else
 				sp->free = next;
 		} else { /* fragment */
-			printk( KERN_ALERT "ALLOC Not exact fit.\n" );
+			//printk( KERN_ALERT "ALLOC Not exact fit.\n" );
 			if (prev)
 				set_slob(prev, slob_units(prev), cur + SLOB_UNITS(size));
 			else
@@ -586,7 +586,7 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 	if( best.cur == NULL ) {		
 	/* Not enough space: must allocate a new page */
 		numPages++;
-		printk( KERN_ALERT "Require moar sandvich! %d\n", numPages );
+		//printk( KERN_ALERT "Require moar sandvich! %d\n", numPages );
 		b = slob_new_pages(gfp & ~__GFP_ZERO, 0, node);
 		if (!b)
 			return NULL;
-- 
1.5.2.1


From 90f7972075af3e3ae1a73cf4002a236a35f203ed Mon Sep 17 00:00:00 2001
From: ClisbyS <clisbys@onid.orst.edu>
Date: Mon, 8 Nov 2010 21:16:17 -0800
Subject: [PATCH] Removing debugging code

---
 linux-2.6.34.7/mm/slob.c |  135 ++++-----------------------------------------
 1 files changed, 12 insertions(+), 123 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index 484cc26..0b91805 100755
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -301,12 +301,6 @@ static void find_best_fit_block(struct slob_page *sp, struct best_block_slob *be
 	int i = 0;
 
         for (prev = NULL, cur = sp->free; ; prev = cur, cur = slob_next(cur)) {
-	//printk( KERN_ALERT "i=%d   ", i );
-	i++;
-	/*if ( best->cur == cur ) {
-		printk( KERN_ALERT "Loop around failure   " );
-                break;
-	}*/
         slobidx_t avail = slob_units(cur);
 
                 if (align) {
@@ -317,70 +311,30 @@ static void find_best_fit_block(struct slob_page *sp, struct best_block_slob *be
                 if (avail >= units + delta) { /* room enough? */
                         slob_t *next;
 
-
-                        if (delta) { // need to fragment head to align?
-				//printk( KERN_ALERT "Best fit has alignment: " );
-                                /*next = slob_next(cur);
-                                set_slob(aligned, avail - delta, next);
-                                set_slob(cur, delta, aligned);
-                                prev = cur;
-                                cur = aligned;
-                                avail = slob_units(cur);
-				if((avail - units) < (best->block_size - best->object_size)) {
-					best->prev = prev;
-					best->cur = cur;
-					best->next = next;
-					best->object_size = units;
-					best->block_size = avail;
-					best->page = sp;
-				}*/
-				
-                        }
-
-
                         next = slob_next(cur);
                         if (avail == units + delta ) { /* exact fit? unlink. */
-                                //if (prev)
-					//printk( KERN_ALERT "Best fit is exact!\n" );
-					best->prev = prev;
-					best->cur = cur;
-					best->next = next;
-					best->object_size = units;
-					best->block_size = avail;
-					best->page = sp;
-                                	// set_slob(prev, slob_units(prev), next);
-                                //else
-                                  //      sp->free = next;
+				best->prev = prev;
+				best->cur = cur;
+				best->next = next;
+				best->object_size = units;
+				best->block_size = avail;
+				best->page = sp;
                         }
 			else { /* fragment */
-                                //if (prev)
-                                  //      set_slob(prev, slob_units(prev), cur + units);
-                                //else
-                                //       sp->free = cur + units;
-                                //set_slob(cur + units, avail - units, next);
 				if ((avail - ( units + delta ) ) < (best->block_size - best->object_size)) {
-					//printk( KERN_ALERT "Best fit is not exact...\n" );
 					best->prev = prev;
-                                        best->cur = cur;
-                                        best->next = next;
-                                        best->object_size = units;
+                                	best->cur = cur;
+                                	best->next = next;
+                                	best->object_size = units;
                                         best->block_size = avail;
 					best->page = sp;
 				}
                         }
-
-                        //sp->units -= units;
-                        //if (!sp->units)
-                        //        clear_slob_page_free(sp);
-                        //return cur;
                 }
-		//printk( "slob_last(cur) == %d, sp: %lu, cur: %lu\n", slob_last(cur), (unsigned long)sp, (unsigned long)cur );
                 if ( slob_last(cur) ) {
-			//printk( KERN_ALERT "Hit end of block     " );
                         break;
 		}
         }
-	//printk( KERN_ALERT "and out of block.\n" );
 }
 
 /*
@@ -441,7 +395,6 @@ static void *slob_page_alloc(struct slob_page *sp, size_t size, int align)
 static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 {
 	struct slob_page *sp;
-	//struct list_head *prev_loop;
 	slob_t *prev;
 	slob_t *next;
 	slob_t *aligned;
@@ -450,19 +403,10 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 	unsigned long flags;
 	struct best_block_slob best;
 	slobidx_t avail;
-	int delta = 0, numPages = 0, iterPage = 0;
-	//printk( KERN_ALERT "Enter slob_alloc, size: %lu\n", size );
-	//printk( KERN_ALERT "Require alignment: %d.\n", align );
-	
-	//if (size < SLOB_BREAK1)
-		slob_list = &free_slob_small;
-	//else if (size < SLOB_BREAK2)
-	//	slob_list = &free_slob_medium;
-	//else
-	//	slob_list = &free_slob_large;
+	int delta = 0;
 	
+	slob_list = &free_slob_small;
 	
-	//this could be bad
 	best.block_size = PAGE_SIZE + 1;
 	best.object_size = SLOB_UNITS(size);
 	best.prev = NULL;
@@ -488,37 +432,11 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 			continue;
 
 		/* Attempt to alloc */
-		//prev_loop = sp->list.prev;
-		//b = slob_page_alloc(sp, size, align);
 		find_best_fit_block(sp, &best, size, align);
-
-
-		/*if((best.block_size - best.object_size) == 0){
-			break;
-		}*/
-
-
-		//if (!b)
-		//	continue;
-
-		/* Improve fragment distribution and reduce our average
-		 * search time by starting our next search here. (see
-		 * Knuth vol 1, sec 2.5, pg 449) */
-		//if (prev != slob_list->prev &&
-		//		slob_list->next != prev->next)
-		//	list_move_tail(slob_list, prev->next);
-		//break;
 	}
 
-	//printk( KERN_ALERT "Exited for lolololoop. iterPage: %d\n", iterPage );
-
-	//spin_unlock_irqrestore(&slob_lock, flags);
-
-
 	/* Sommit found */
 	if (best.cur != NULL) {
-		//printk( KERN_ALERT "best.cur found!\n" );
-
 		cur = best.cur;
 		prev = best.prev;
 		sp = best.page;
@@ -528,23 +446,8 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 			aligned = (slob_t *) ALIGN ((unsigned long)cur, align);
 			delta = aligned - cur;
 		}
-		//if (
-/*slob_t *prev, *cur, *aligned = NULL;
-	int delta = 0, units = SLOB_UNITS(size);
-
-	for (prev = NULL, cur = sp->free; ; prev = cur, cur = slob_next(cur)) {
-	slobidx_t avail = slob_units(cur);
-
-		if (align) {
-			aligned = (slob_t *)ALIGN((unsigned long)cur, align);
-			delta = aligned - cur;
-		}*/
-		//if (avail >= units + delta) { /* room enough? */
-		
-		
 
 		if (delta) { /* need to fragment head to align? */
-			//printk( KERN_ALERT "Fragment w/ delta: %d\n", delta );
 			next = slob_next(cur);
 			set_slob(aligned, avail - delta, next);
 			set_slob(cur, delta, aligned);
@@ -555,13 +458,11 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 
 		next = slob_next(cur);
 		if (avail == SLOB_UNITS(size)) { /* exact fit? unlink. */
-			//printk( KERN_ALERT "ALLOC Exact fit.\n" );
 			if (prev)
 				set_slob(prev, slob_units(prev), next);
 			else
 				sp->free = next;
 		} else { /* fragment */
-			//printk( KERN_ALERT "ALLOC Not exact fit.\n" );
 			if (prev)
 				set_slob(prev, slob_units(prev), cur + SLOB_UNITS(size));
 			else
@@ -573,20 +474,13 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 		if (!sp->units)
 			clear_slob_page_free(sp);
 
-
 		b = cur;
-		//return cur;
-	//}
-	//if (slob_last(cur))
-		//return NULL;
 	}
 
 	spin_unlock_irqrestore(&slob_lock, flags);
 
 	if( best.cur == NULL ) {		
 	/* Not enough space: must allocate a new page */
-		numPages++;
-		//printk( KERN_ALERT "Require moar sandvich! %d\n", numPages );
 		b = slob_new_pages(gfp & ~__GFP_ZERO, 0, node);
 		if (!b)
 			return NULL;
@@ -602,13 +496,8 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 		b = slob_page_alloc(sp, size, align);
 		BUG_ON(!b);
 		spin_unlock_irqrestore(&slob_lock, flags);
-
-		/* Increment number of pages allocated. */
-		//pages_alloc++;
 	}
 
-	
-
 	if (unlikely((gfp & __GFP_ZERO) && b))
 		memset(b, 0, size);
 	return b;
@@ -640,7 +529,7 @@ static void slob_free(void *block, int size)
 		spin_unlock_irqrestore(&slob_lock, flags);
 		clear_slob_page(sp);
 		/* Decrement number of pages allocated. */
-		pages_alloc--; //CHINGAS
+		pages_alloc--;
 		free_slob_page(sp);
 		slob_free_pages(b, 0);
 		return;
-- 
1.5.2.1


From 6fe735614f05e72229a605afa93431a118b9e882 Mon Sep 17 00:00:00 2001
From: Matt Thomas <baddack@gmail.com>
Date: Mon, 8 Nov 2010 21:16:38 -0800
Subject: [PATCH] added README file

---
 linux-2.6.34.7/simple/README.txt |   15 +++++++++++++++
 1 files changed, 15 insertions(+), 0 deletions(-)
 create mode 100644 linux-2.6.34.7/simple/README.txt

diff --git a/linux-2.6.34.7/simple/README.txt b/linux-2.6.34.7/simple/README.txt
new file mode 100644
index 0000000..8b4f079
--- /dev/null
+++ b/linux-2.6.34.7/simple/README.txt
@@ -0,0 +1,15 @@
+CS 411
+Group 2
+Matt Thomas, Matt Martinson, Ian Crawford, Sarah Clisby
+
+Here are the results of our First Fit Algorithm:
+
+     Claimed Memory: 119291904	 = ~119MB
+     Free Memory:    219434	 = ~219KB
+
+Here are the results of our Best Fit Algorithm:
+
+     Claimed Memory: 119316480	 = ~119MB
+     Free Memory:    55884	 = ~55KB
+
+As seen above, the best fit algorith greatly reduced fragmentaion at the expense of speed.
\ No newline at end of file
-- 
1.5.2.1


From 83f7b1c967a1fcf3b81d48ceae631c1803a57baf Mon Sep 17 00:00:00 2001
From: Matt Thomas <baddack@gmail.com>
Date: Mon, 8 Nov 2010 22:05:03 -0800
Subject: [PATCH] Commented code up to standard

---
 linux-2.6.34.7/mm/slob.c |   18 ++++++++++++++----
 1 files changed, 14 insertions(+), 4 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index 0b91805..226c6c1 100755
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -1,5 +1,13 @@
-//CS 411 Group 2
-//Matt Thomas, Matt Martinson, Ian Crawford, Sarah Clisby
+/* CS 411 Group 2
+ * Matt Thomas, Matt Martinson, Ian Crawford, Sarah Clisby
+ * In this program, we added a new method called find_best_fit_block,
+ * this essentially does what the method's name suggests, it searches
+ * for the best fit block in a given page, and saves it to a struct 
+ * called best_block_slob. We also changed slob_alloc so that it 
+ * would loop through the blocks in which we got rid of small, medium,
+ * and large, and made them into one big list. 
+ */
+
 /*
  * SLOB Allocator: Simple List Of Blocks
  *
@@ -293,7 +301,7 @@ static void slob_free_pages(void *b, int order)
 
 /*
  * Finds best fit block in a given slob_page sp.
-*/
+ */
 static void find_best_fit_block(struct slob_page *sp, struct best_block_slob *best, size_t size, int align)
 {
 	slob_t *prev, *cur, *aligned = NULL;
@@ -339,7 +347,9 @@ static void find_best_fit_block(struct slob_page *sp, struct best_block_slob *be
 
 /*
  * Allocate a slob block within a given slob_page sp.
+ * We ended up not changing this method at all.
  */
+
 static void *slob_page_alloc(struct slob_page *sp, size_t size, int align)
 {
 	slob_t *prev, *cur, *aligned = NULL;
@@ -435,7 +445,7 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 		find_best_fit_block(sp, &best, size, align);
 	}
 
-	/* Sommit found */
+	/* Best fit found */
 	if (best.cur != NULL) {
 		cur = best.cur;
 		prev = best.prev;
-- 
1.5.2.1


From ec8c6f2bb54bd2a9ae74c0c1822f7aeee5f45323 Mon Sep 17 00:00:00 2001
From: ClisbyS <clisbys@onid.orst.edu>
Date: Mon, 8 Nov 2010 22:15:13 -0800
Subject: [PATCH] Made a couple more minor comments

---
 linux-2.6.34.7/mm/slob.c |    8 +++++++-
 1 files changed, 7 insertions(+), 1 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index 226c6c1..b1031c3 100755
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -301,6 +301,8 @@ static void slob_free_pages(void *b, int order)
 
 /*
  * Finds best fit block in a given slob_page sp.
+ * Checks found block against block in
+ * best_block_slob structure, replacing if better.
  */
 static void find_best_fit_block(struct slob_page *sp, struct best_block_slob *best, size_t size, int align)
 {
@@ -347,7 +349,8 @@ static void find_best_fit_block(struct slob_page *sp, struct best_block_slob *be
 
 /*
  * Allocate a slob block within a given slob_page sp.
- * We ended up not changing this method at all.
+ * We ended up not changing this method at all, nor
+ * using it.
  */
 
 static void *slob_page_alloc(struct slob_page *sp, size_t size, int align)
@@ -401,6 +404,9 @@ static void *slob_page_alloc(struct slob_page *sp, size_t size, int align)
 
 /*
  * slob_alloc: entry point into the slob allocator.
+ *
+ * Changed to loop through all pages, looking for pages with enough room
+ * for allocation.
  */
 static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 {
-- 
1.5.2.1


From 07bdfe088444106af33dc56ccbe7fc85868aa7bb Mon Sep 17 00:00:00 2001
From: ClisbyS <clisbys@onid.orst.edu>
Date: Mon, 8 Nov 2010 22:23:05 -0800
Subject: [PATCH] Fixed a small bug

---
 linux-2.6.34.7/mm/slob.c |    1 -
 1 files changed, 0 insertions(+), 1 deletions(-)

diff --git a/linux-2.6.34.7/mm/slob.c b/linux-2.6.34.7/mm/slob.c
index b1031c3..82858c0 100755
--- a/linux-2.6.34.7/mm/slob.c
+++ b/linux-2.6.34.7/mm/slob.c
@@ -443,7 +443,6 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 			continue;
 #endif
 		/* Enough room on this page? */
-		iterPage++;
 		if (sp->units < SLOB_UNITS(size))
 			continue;
 
-- 
1.5.2.1

